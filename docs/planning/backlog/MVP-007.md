# MVP-007: API Request Processing & Response System

**Feature:** MVP-Backend
**Priority:** P0 (Critical)
**Effort:** Medium (3 days)
**Dependencies:** MVP-001 (PostgreSQL Setup), MVP-005 (Journal Service)

## Objective

Implement comprehensive API request processing pipeline with validation, error handling, response formatting, middleware chain, and performance optimization to provide a robust and secure HTTP API interface.

## Technical Scope

### Request Processing Pipeline

- HTTP request parsing and validation
- Structured input validation with custom rules
- Content-type handling (JSON, multipart/form-data)
- Request size limits and security validation
- Middleware chain for cross-cutting concerns

### Response Management

- Standardized response formatting
- Error response handling with proper HTTP status codes
- Pagination for list endpoints
- Response compression and optimization
- CORS handling and security headers

### Performance & Security

- Request/response logging and monitoring
- Rate limiting per endpoint and user
- Request timeout handling
- Response caching headers
- Security middleware (CSRF, XSS protection)

## Acceptance Criteria

### Request Processing

- [ ] Parse and validate all incoming JSON and form data
- [ ] Implement comprehensive input validation with custom rules
- [ ] Handle file uploads with size and type validation
- [ ] Apply request timeouts and size limits
- [ ] Support content negotiation (JSON primarily)

### Response Formatting

- [ ] Standardized JSON response format across all endpoints
- [ ] Proper HTTP status codes for all scenarios
- [ ] Paginated responses with metadata
- [ ] Error responses with detailed context
- [ ] Consistent timestamp formatting (RFC3339)

### Performance Requirements

- [ ] Request processing overhead under 5ms
- [ ] Response compression reduces payload by 60%+
- [ ] Request validation completes under 10ms
- [ ] Memory usage remains constant under load
- [ ] Handle 1000+ concurrent requests efficiently

## Implementation Details

### Request Processing Pipeline

```go
type RequestProcessor struct {
    validator      *Validator
    logger         *slog.Logger
    metrics        *RequestMetrics
    config         RequestProcessorConfig
    sanitizer      *Sanitizer
}

type RequestProcessorConfig struct {
    MaxRequestSize        int64         `env:"MAX_REQUEST_SIZE" default:"10485760"` // 10MB
    RequestTimeout        time.Duration `env:"REQUEST_TIMEOUT" default:"30s"`
    EnableCompression     bool          `env:"ENABLE_COMPRESSION" default:"true"`
    CompressionLevel      int           `env:"COMPRESSION_LEVEL" default:"6"`
    MaxUploadSize         int64         `env:"MAX_UPLOAD_SIZE" default:"52428800"` // 50MB
    AllowedContentTypes   []string      `env:"ALLOWED_CONTENT_TYPES" default:"application/json,multipart/form-data"`
    EnableRequestLogging  bool          `env:"ENABLE_REQUEST_LOGGING" default:"true"`
    LogRequestBody        bool          `env:"LOG_REQUEST_BODY" default:"false"`
    CORSAllowedOrigins    []string      `env:"CORS_ALLOWED_ORIGINS" default:"*"`
    CORSAllowedMethods    []string      `env:"CORS_ALLOWED_METHODS" default:"GET,POST,PUT,DELETE,OPTIONS"`
    CORSAllowedHeaders    []string      `env:"CORS_ALLOWED_HEADERS" default:"Content-Type,Authorization,X-Requested-With"`
    CORSMaxAge            int           `env:"CORS_MAX_AGE" default:"86400"`
}

func NewRequestProcessor(
    validator *Validator,
    logger *slog.Logger,
    config RequestProcessorConfig,
) *RequestProcessor {
    return &RequestProcessor{
        validator: validator,
        logger:    logger,
        config:    config,
        metrics:   NewRequestMetrics(),
        sanitizer: NewSanitizer(),
    }
}

// Middleware chain setup
func (rp *RequestProcessor) SetupMiddleware(router *gin.Engine) {
    // Security headers
    router.Use(rp.SecurityHeadersMiddleware())

    // CORS handling
    router.Use(rp.CORSMiddleware())

    // Request logging
    if rp.config.EnableRequestLogging {
        router.Use(rp.RequestLoggingMiddleware())
    }

    // Request size limits
    router.Use(rp.RequestSizeLimitMiddleware())

    // Content type validation
    router.Use(rp.ContentTypeValidationMiddleware())

    // Request timeout
    router.Use(rp.RequestTimeoutMiddleware())

    // Recovery from panics
    router.Use(rp.RecoveryMiddleware())

    // Response compression
    if rp.config.EnableCompression {
        router.Use(rp.CompressionMiddleware())
    }

    // Request metrics
    router.Use(rp.MetricsMiddleware())
}

func (rp *RequestProcessor) SecurityHeadersMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Security headers
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")

        // Content Security Policy
        csp := "default-src 'self'; " +
               "script-src 'self' 'unsafe-inline'; " +
               "style-src 'self' 'unsafe-inline'; " +
               "img-src 'self' data: https:; " +
               "font-src 'self'; " +
               "connect-src 'self'; " +
               "frame-ancestors 'none'; " +
               "base-uri 'self'; " +
               "object-src 'none'"
        c.Header("Content-Security-Policy", csp)

        c.Next()
    }
}

func (rp *RequestProcessor) CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")

        // Check if origin is allowed
        if rp.isAllowedOrigin(origin) {
            c.Header("Access-Control-Allow-Origin", origin)
        } else if rp.config.CORSAllowedOrigins[0] == "*" {
            c.Header("Access-Control-Allow-Origin", "*")
        }

        c.Header("Access-Control-Allow-Methods", strings.Join(rp.config.CORSAllowedMethods, ","))
        c.Header("Access-Control-Allow-Headers", strings.Join(rp.config.CORSAllowedHeaders, ","))
        c.Header("Access-Control-Max-Age", strconv.Itoa(rp.config.CORSMaxAge))
        c.Header("Access-Control-Allow-Credentials", "true")

        // Handle preflight requests
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }

        c.Next()
    }
}

func (rp *RequestProcessor) RequestLoggingMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // Create request ID
        requestID := uuid.New().String()
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)

        // Log request
        rp.logRequest(c, requestID)

        // Process request
        c.Next()

        // Log response
        rp.logResponse(c, requestID, time.Since(start))
    }
}

func (rp *RequestProcessor) RequestSizeLimitMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Check content length
        if c.Request.ContentLength > rp.config.MaxRequestSize {
            rp.RespondWithError(c, http.StatusRequestEntityTooLarge,
                "Request body too large", "REQUEST_TOO_LARGE", nil)
            return
        }

        // Wrap request body with size limit
        c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, rp.config.MaxRequestSize)

        c.Next()
    }
}

func (rp *RequestProcessor) ContentTypeValidationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Skip validation for GET, DELETE, HEAD requests
        if c.Request.Method == "GET" || c.Request.Method == "DELETE" || c.Request.Method == "HEAD" {
            c.Next()
            return
        }

        contentType := c.Request.Header.Get("Content-Type")
        if contentType == "" {
            rp.RespondWithError(c, http.StatusBadRequest,
                "Content-Type header is required", "MISSING_CONTENT_TYPE", nil)
            return
        }

        // Extract media type (ignore charset, boundary, etc.)
        mediaType, _, err := mime.ParseMediaType(contentType)
        if err != nil {
            rp.RespondWithError(c, http.StatusBadRequest,
                "Invalid Content-Type header", "INVALID_CONTENT_TYPE", nil)
            return
        }

        // Check if content type is allowed
        if !rp.isAllowedContentType(mediaType) {
            rp.RespondWithError(c, http.StatusUnsupportedMediaType,
                "Unsupported Content-Type", "UNSUPPORTED_CONTENT_TYPE",
                gin.H{"allowed_types": rp.config.AllowedContentTypes})
            return
        }

        c.Next()
    }
}

func (rp *RequestProcessor) RequestTimeoutMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Create context with timeout
        ctx, cancel := context.WithTimeout(c.Request.Context(), rp.config.RequestTimeout)
        defer cancel()

        // Replace request context
        c.Request = c.Request.WithContext(ctx)

        // Monitor for timeout
        done := make(chan bool, 1)

        go func() {
            c.Next()
            done <- true
        }()

        select {
        case <-done:
            // Request completed normally
            return
        case <-ctx.Done():
            // Request timed out
            rp.RespondWithError(c, http.StatusRequestTimeout,
                "Request timeout", "REQUEST_TIMEOUT", nil)
            c.Abort()
            return
        }
    }
}

func (rp *RequestProcessor) RecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Log the panic
                requestID, _ := c.Get("request_id")
                rp.logger.Error("Panic recovered",
                    "request_id", requestID,
                    "error", err,
                    "stack", string(debug.Stack()))

                // Increment panic metric
                rp.metrics.PanicsRecovered.Inc()

                // Return error response
                if !c.Writer.Written() {
                    rp.RespondWithError(c, http.StatusInternalServerError,
                        "Internal server error", "INTERNAL_ERROR", nil)
                }

                c.Abort()
            }
        }()

        c.Next()
    }
}

func (rp *RequestProcessor) CompressionMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Check if client accepts compression
        if !strings.Contains(c.Request.Header.Get("Accept-Encoding"), "gzip") {
            c.Next()
            return
        }

        // Skip compression for small responses or specific content types
        if rp.shouldSkipCompression(c) {
            c.Next()
            return
        }

        // Set compression headers
        c.Header("Content-Encoding", "gzip")
        c.Header("Vary", "Accept-Encoding")

        // Create gzip writer
        gz, err := gzip.NewWriterLevel(c.Writer, rp.config.CompressionLevel)
        if err != nil {
            c.Next()
            return
        }
        defer gz.Close()

        // Wrap response writer
        c.Writer = &gzipResponseWriter{
            ResponseWriter: c.Writer,
            gzipWriter:     gz,
        }

        c.Next()
    }
}

func (rp *RequestProcessor) MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // Process request
        c.Next()

        // Record metrics
        duration := time.Since(start)
        status := strconv.Itoa(c.Writer.Status())
        method := c.Request.Method
        endpoint := c.FullPath()

        rp.metrics.RequestDuration.WithLabelValues(method, endpoint, status).Observe(duration.Seconds())
        rp.metrics.RequestsTotal.WithLabelValues(method, endpoint, status).Inc()
        rp.metrics.RequestSize.WithLabelValues(method, endpoint).Observe(float64(c.Request.ContentLength))
        rp.metrics.ResponseSize.WithLabelValues(method, endpoint).Observe(float64(c.Writer.Size()))
    }
}
```

### Response Management System

```go
type StandardResponse struct {
    Success   bool        `json:"success"`
    Data      any         `json:"data,omitempty"`
    Error     *ErrorInfo  `json:"error,omitempty"`
    Meta      *ResponseMeta `json:"meta,omitempty"`
    Timestamp string      `json:"timestamp"`
}

type ErrorInfo struct {
    Code    string         `json:"code"`
    Message string         `json:"message"`
    Details map[string]any `json:"details,omitempty"`
    Trace   string         `json:"trace,omitempty"`
}

type ResponseMeta struct {
    RequestID    string      `json:"request_id,omitempty"`
    Pagination   *Pagination `json:"pagination,omitempty"`
    Performance  *Performance `json:"performance,omitempty"`
    Version      string      `json:"version,omitempty"`
}

type Pagination struct {
    Page       int  `json:"page"`
    Limit      int  `json:"limit"`
    Total      int  `json:"total"`
    TotalPages int  `json:"total_pages"`
    HasNext    bool `json:"has_next"`
    HasPrev    bool `json:"has_prev"`
}

type Performance struct {
    ProcessingTime string `json:"processing_time"`
    CacheHit       bool   `json:"cache_hit,omitempty"`
    DBQueries      int    `json:"db_queries,omitempty"`
}

func (rp *RequestProcessor) RespondWithSuccess(c *gin.Context, statusCode int, data any) {
    rp.respondWithStandard(c, statusCode, true, data, nil)
}

func (rp *RequestProcessor) RespondWithError(c *gin.Context, statusCode int, message, code string, details map[string]any) {
    errorInfo := &ErrorInfo{
        Code:    code,
        Message: message,
        Details: details,
    }

    // Add trace in development mode
    if rp.config.EnableDebugTrace {
        errorInfo.Trace = string(debug.Stack())
    }

    rp.respondWithStandard(c, statusCode, false, nil, errorInfo)
}

func (rp *RequestProcessor) RespondWithValidationError(c *gin.Context, validationErrors []FieldError) {
    details := make(map[string]any)
    details["field_errors"] = validationErrors

    rp.RespondWithError(c, http.StatusBadRequest,
        "Validation failed", "VALIDATION_ERROR", details)
}

func (rp *RequestProcessor) RespondWithPagination(c *gin.Context, statusCode int, data any, pagination *Pagination) {
    response := &StandardResponse{
        Success:   true,
        Data:      data,
        Meta:      &ResponseMeta{Pagination: pagination},
        Timestamp: time.Now().Format(time.RFC3339),
    }

    rp.addResponseMeta(c, response)
    c.JSON(statusCode, response)
}

func (rp *RequestProcessor) respondWithStandard(c *gin.Context, statusCode int, success bool, data any, errorInfo *ErrorInfo) {
    response := &StandardResponse{
        Success:   success,
        Data:      data,
        Error:     errorInfo,
        Timestamp: time.Now().Format(time.RFC3339),
    }

    rp.addResponseMeta(c, response)
    c.JSON(statusCode, response)
}

func (rp *RequestProcessor) addResponseMeta(c *gin.Context, response *StandardResponse) {
    if response.Meta == nil {
        response.Meta = &ResponseMeta{}
    }

    // Add request ID
    if requestID, exists := c.Get("request_id"); exists {
        response.Meta.RequestID = requestID.(string)
    }

    // Add performance information
    if startTime, exists := c.Get("start_time"); exists {
        duration := time.Since(startTime.(time.Time))
        if response.Meta.Performance == nil {
            response.Meta.Performance = &Performance{}
        }
        response.Meta.Performance.ProcessingTime = duration.String()
    }

    // Add cache hit information
    if cacheHit, exists := c.Get("cache_hit"); exists {
        if response.Meta.Performance == nil {
            response.Meta.Performance = &Performance{}
        }
        response.Meta.Performance.CacheHit = cacheHit.(bool)
    }

    // Add DB query count
    if dbQueries, exists := c.Get("db_queries"); exists {
        if response.Meta.Performance == nil {
            response.Meta.Performance = &Performance{}
        }
        response.Meta.Performance.DBQueries = dbQueries.(int)
    }

    // Add API version
    response.Meta.Version = "v1"
}
```

### Request Validation System

```go
type RequestValidator struct {
    validate    *validator.Validate
    sanitizer   *Sanitizer
    config      ValidationConfig
}

type ValidationConfig struct {
    MaxStringLength       int  `env:"MAX_STRING_LENGTH" default:"10000"`
    MaxArraySize          int  `env:"MAX_ARRAY_SIZE" default:"1000"`
    StrictValidation      bool `env:"STRICT_VALIDATION" default:"true"`
    SanitizeInput         bool `env:"SANITIZE_INPUT" default:"true"`
    AllowUnknownFields    bool `env:"ALLOW_UNKNOWN_FIELDS" default:"false"`
    ValidateEmptyStrings  bool `env:"VALIDATE_EMPTY_STRINGS" default:"true"`
}

type FieldError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
    Code    string `json:"code"`
    Value   any    `json:"value,omitempty"`
}

func NewRequestValidator(config ValidationConfig) *RequestValidator {
    validate := validator.New()

    // Register custom validators
    validate.RegisterValidation("journal_content", validateJournalContent)
    validate.RegisterValidation("safe_string", validateSafeString)
    validate.RegisterValidation("timezone", validateTimezone)
    validate.RegisterValidation("language", validateLanguage)
    validate.RegisterValidation("uuid", validateUUID)
    validate.RegisterValidation("slug", validateSlug)
    validate.RegisterValidation("json", validateJSON)

    return &RequestValidator{
        validate:  validate,
        sanitizer: NewSanitizer(),
        config:    config,
    }
}

func (rv *RequestValidator) ValidateStruct(s any) []FieldError {
    var fieldErrors []FieldError

    err := rv.validate.Struct(s)
    if err != nil {
        for _, err := range err.(validator.ValidationErrors) {
            fieldError := FieldError{
                Field:   rv.getJSONFieldName(err),
                Message: rv.getErrorMessage(err),
                Code:    rv.getErrorCode(err.Tag()),
                Value:   err.Value(),
            }
            fieldErrors = append(fieldErrors, fieldError)
        }
    }

    return fieldErrors
}

func (rv *RequestValidator) ValidateAndSanitize(s any) ([]FieldError, error) {
    // Sanitize input if enabled
    if rv.config.SanitizeInput {
        if err := rv.sanitizeStruct(s); err != nil {
            return nil, fmt.Errorf("sanitization failed: %w", err)
        }
    }

    // Validate structure
    fieldErrors := rv.ValidateStruct(s)

    return fieldErrors, nil
}

func (rv *RequestValidator) sanitizeStruct(s any) error {
    value := reflect.ValueOf(s)
    if value.Kind() == reflect.Ptr {
        value = value.Elem()
    }

    if value.Kind() != reflect.Struct {
        return nil
    }

    for i := 0; i < value.NumField(); i++ {
        field := value.Field(i)
        fieldType := value.Type().Field(i)

        // Skip unexported fields
        if !field.CanSet() {
            continue
        }

        switch field.Kind() {
        case reflect.String:
            sanitized := rv.sanitizer.Sanitize(field.String())
            field.SetString(sanitized)

        case reflect.Ptr:
            if !field.IsNil() && field.Elem().Kind() == reflect.String {
                original := field.Elem().String()
                sanitized := rv.sanitizer.Sanitize(original)
                field.Elem().SetString(sanitized)
            }

        case reflect.Slice:
            if field.Type().Elem().Kind() == reflect.String {
                for j := 0; j < field.Len(); j++ {
                    item := field.Index(j)
                    sanitized := rv.sanitizer.Sanitize(item.String())
                    item.SetString(sanitized)
                }
            }

        case reflect.Map:
            if field.Type().Key().Kind() == reflect.String && field.Type().Elem().Kind() == reflect.Interface {
                rv.sanitizeMap(field.Interface().(map[string]any))
            }

        case reflect.Struct:
            // Recursively sanitize nested structs
            rv.sanitizeStruct(field.Addr().Interface())
        }

        // Check field-specific constraints
        if err := rv.validateFieldConstraints(field, fieldType); err != nil {
            return err
        }
    }

    return nil
}

func (rv *RequestValidator) sanitizeMap(m map[string]any) {
    for k, v := range m {
        switch val := v.(type) {
        case string:
            m[k] = rv.sanitizer.Sanitize(val)
        case map[string]any:
            rv.sanitizeMap(val)
        case []any:
            for i, item := range val {
                if str, ok := item.(string); ok {
                    val[i] = rv.sanitizer.Sanitize(str)
                }
            }
        }
    }
}

func (rv *RequestValidator) validateFieldConstraints(field reflect.Value, fieldType reflect.StructField) error {
    // Check string length constraints
    if field.Kind() == reflect.String {
        if field.Len() > rv.config.MaxStringLength {
            return fmt.Errorf("field %s exceeds maximum length", fieldType.Name)
        }
    }

    // Check slice size constraints
    if field.Kind() == reflect.Slice {
        if field.Len() > rv.config.MaxArraySize {
            return fmt.Errorf("field %s exceeds maximum array size", fieldType.Name)
        }
    }

    return nil
}

// Custom validation functions
func validateJournalContent(fl validator.FieldLevel) bool {
    content := fl.Field().String()

    // Must not be empty or only whitespace
    if strings.TrimSpace(content) == "" {
        return false
    }

    // Check for reasonable length (between 1 and 50,000 characters)
    if len(content) < 1 || len(content) > 50000 {
        return false
    }

    // Check for potentially malicious content
    suspiciousPatterns := []string{
        "<script", "javascript:", "vbscript:", "onload=", "onerror=",
    }

    lowerContent := strings.ToLower(content)
    for _, pattern := range suspiciousPatterns {
        if strings.Contains(lowerContent, pattern) {
            return false
        }
    }

    return true
}

func validateSafeString(fl validator.FieldLevel) bool {
    str := fl.Field().String()

    // Check for SQL injection patterns
    sqlPatterns := []string{
        "drop table", "delete from", "insert into", "update set",
        "'or'1'='1", "admin'--", "' or 1=1--",
    }

    lowerStr := strings.ToLower(str)
    for _, pattern := range sqlPatterns {
        if strings.Contains(lowerStr, pattern) {
            return false
        }
    }

    // Check for XSS patterns
    xssPatterns := []string{
        "<script>", "</script>", "javascript:", "vbscript:",
        "onload=", "onerror=", "onclick=", "onmouseover=",
    }

    for _, pattern := range xssPatterns {
        if strings.Contains(lowerStr, pattern) {
            return false
        }
    }

    return true
}

func validateTimezone(fl validator.FieldLevel) bool {
    tz := fl.Field().String()
    _, err := time.LoadLocation(tz)
    return err == nil
}

func validateLanguage(fl validator.FieldLevel) bool {
    lang := fl.Field().String()
    validLanguages := []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "ko", "zh"}

    for _, valid := range validLanguages {
        if lang == valid {
            return true
        }
    }
    return false
}

func validateUUID(fl validator.FieldLevel) bool {
    _, err := uuid.Parse(fl.Field().String())
    return err == nil
}

func validateSlug(fl validator.FieldLevel) bool {
    slug := fl.Field().String()

    // Slug should only contain lowercase letters, numbers, and hyphens
    match, _ := regexp.MatchString("^[a-z0-9-]+$", slug)
    if !match {
        return false
    }

    // Should not start or end with hyphen
    if strings.HasPrefix(slug, "-") || strings.HasSuffix(slug, "-") {
        return false
    }

    // Should not contain consecutive hyphens
    if strings.Contains(slug, "--") {
        return false
    }

    return true
}

func validateJSON(fl validator.FieldLevel) bool {
    str := fl.Field().String()

    var temp any
    return json.Unmarshal([]byte(str), &temp) == nil
}
```

### Request Parsing Utilities

```go
type RequestParser struct {
    maxMemory  int64
    validator  *RequestValidator
    logger     *slog.Logger
}

func NewRequestParser(maxMemory int64, validator *RequestValidator, logger *slog.Logger) *RequestParser {
    return &RequestParser{
        maxMemory: maxMemory,
        validator: validator,
        logger:    logger,
    }
}

func (rp *RequestParser) ParseJSON(c *gin.Context, dest any) []FieldError {
    // Bind JSON data
    if err := c.ShouldBindJSON(dest); err != nil {
        rp.logger.Warn("JSON binding failed", "error", err)

        // Convert binding error to field errors
        if validationErrors, ok := err.(validator.ValidationErrors); ok {
            var fieldErrors []FieldError
            for _, err := range validationErrors {
                fieldError := FieldError{
                    Field:   err.Field(),
                    Message: err.Error(),
                    Code:    "BINDING_ERROR",
                }
                fieldErrors = append(fieldErrors, fieldError)
            }
            return fieldErrors
        }

        // Generic JSON parsing error
        return []FieldError{{
            Field:   "body",
            Message: "Invalid JSON format",
            Code:    "INVALID_JSON",
        }}
    }

    // Validate and sanitize
    fieldErrors, err := rp.validator.ValidateAndSanitize(dest)
    if err != nil {
        rp.logger.Error("Validation failed", "error", err)
        return []FieldError{{
            Field:   "body",
            Message: "Validation processing failed",
            Code:    "VALIDATION_ERROR",
        }}
    }

    return fieldErrors
}

func (rp *RequestParser) ParseMultipart(c *gin.Context, dest any) (map[string][]*multipart.FileHeader, []FieldError) {
    // Parse multipart form
    if err := c.Request.ParseMultipartForm(rp.maxMemory); err != nil {
        return nil, []FieldError{{
            Field:   "form",
            Message: "Failed to parse multipart form",
            Code:    "MULTIPART_ERROR",
        }}
    }

    // Bind form data to struct
    if err := c.ShouldBind(dest); err != nil {
        return nil, []FieldError{{
            Field:   "form",
            Message: "Failed to bind form data",
            Code:    "BINDING_ERROR",
        }}
    }

    // Validate and sanitize
    fieldErrors, err := rp.validator.ValidateAndSanitize(dest)
    if err != nil {
        return nil, []FieldError{{
            Field:   "form",
            Message: "Validation processing failed",
            Code:    "VALIDATION_ERROR",
        }}
    }

    // Return files and validation errors
    files := make(map[string][]*multipart.FileHeader)
    if c.Request.MultipartForm != nil {
        files = c.Request.MultipartForm.File
    }

    return files, fieldErrors
}

func (rp *RequestParser) ParseQuery(c *gin.Context, dest any) []FieldError {
    // Bind query parameters
    if err := c.ShouldBindQuery(dest); err != nil {
        return []FieldError{{
            Field:   "query",
            Message: "Failed to bind query parameters",
            Code:    "QUERY_BINDING_ERROR",
        }}
    }

    // Validate and sanitize
    fieldErrors, err := rp.validator.ValidateAndSanitize(dest)
    if err != nil {
        return []FieldError{{
            Field:   "query",
            Message: "Query validation failed",
            Code:    "QUERY_VALIDATION_ERROR",
        }}
    }

    return fieldErrors
}

// Pagination helpers
func (rp *RequestParser) ParsePagination(c *gin.Context, defaultLimit int, maxLimit int) (int, int, []FieldError) {
    var pagination struct {
        Page  int `form:"page" validate:"min=1"`
        Limit int `form:"limit" validate:"min=1"`
    }

    // Set defaults
    pagination.Page = 1
    pagination.Limit = defaultLimit

    // Parse query parameters
    if err := c.ShouldBindQuery(&pagination); err != nil {
        return 1, defaultLimit, []FieldError{{
            Field:   "pagination",
            Message: "Invalid pagination parameters",
            Code:    "PAGINATION_ERROR",
        }}
    }

    // Validate limits
    if pagination.Limit > maxLimit {
        pagination.Limit = maxLimit
    }

    // Calculate offset
    offset := (pagination.Page - 1) * pagination.Limit

    return offset, pagination.Limit, nil
}

func (rp *RequestParser) BuildPaginationResponse(page, limit, total int) *Pagination {
    totalPages := (total + limit - 1) / limit

    return &Pagination{
        Page:       page,
        Limit:      limit,
        Total:      total,
        TotalPages: totalPages,
        HasNext:    page < totalPages,
        HasPrev:    page > 1,
    }
}
```

### Helper Functions

```go
func (rp *RequestProcessor) logRequest(c *gin.Context, requestID string) {
    // Basic request information
    logData := map[string]any{
        "request_id": requestID,
        "method":     c.Request.Method,
        "path":       c.Request.URL.Path,
        "remote_ip":  c.ClientIP(),
        "user_agent": c.Request.UserAgent(),
        "referer":    c.Request.Referer(),
    }

    // Add query parameters if present
    if c.Request.URL.RawQuery != "" {
        logData["query"] = c.Request.URL.RawQuery
    }

    // Add content length if present
    if c.Request.ContentLength > 0 {
        logData["content_length"] = c.Request.ContentLength
    }

    // Add user ID if authenticated
    if userID, exists := c.Get("user_id"); exists {
        logData["user_id"] = userID
    }

    // Log request body in development mode
    if rp.config.LogRequestBody && rp.isDevelopmentMode() {
        if body, err := io.ReadAll(c.Request.Body); err == nil {
            c.Request.Body = io.NopCloser(bytes.NewBuffer(body))
            logData["body"] = string(body)
        }
    }

    rp.logger.Info("HTTP request", logData)
}

func (rp *RequestProcessor) logResponse(c *gin.Context, requestID string, duration time.Duration) {
    logData := map[string]any{
        "request_id":   requestID,
        "status":       c.Writer.Status(),
        "duration_ms":  duration.Milliseconds(),
        "response_size": c.Writer.Size(),
    }

    // Add performance metrics
    if dbQueries, exists := c.Get("db_queries"); exists {
        logData["db_queries"] = dbQueries
    }

    if cacheHit, exists := c.Get("cache_hit"); exists {
        logData["cache_hit"] = cacheHit
    }

    // Log level based on status code
    status := c.Writer.Status()
    if status >= 500 {
        rp.logger.Error("HTTP response", logData)
    } else if status >= 400 {
        rp.logger.Warn("HTTP response", logData)
    } else {
        rp.logger.Info("HTTP response", logData)
    }
}

func (rp *RequestProcessor) isAllowedOrigin(origin string) bool {
    for _, allowed := range rp.config.CORSAllowedOrigins {
        if allowed == "*" || allowed == origin {
            return true
        }
    }
    return false
}

func (rp *RequestProcessor) isAllowedContentType(contentType string) bool {
    for _, allowed := range rp.config.AllowedContentTypes {
        if allowed == contentType {
            return true
        }
    }
    return false
}

func (rp *RequestProcessor) shouldSkipCompression(c *gin.Context) bool {
    // Skip compression for small responses
    if c.Writer.Size() < 1024 {
        return true
    }

    // Skip compression for already compressed content
    contentType := c.Writer.Header().Get("Content-Type")
    compressedTypes := []string{"image/", "video/", "audio/", "application/zip", "application/gzip"}

    for _, t := range compressedTypes {
        if strings.HasPrefix(contentType, t) {
            return true
        }
    }

    return false
}

func (rp *RequestProcessor) isDevelopmentMode() bool {
    return os.Getenv("ENVIRONMENT") == "development"
}

// gzipResponseWriter wraps gin.ResponseWriter with gzip compression
type gzipResponseWriter struct {
    gin.ResponseWriter
    gzipWriter *gzip.Writer
}

func (grw *gzipResponseWriter) Write(data []byte) (int, error) {
    return grw.gzipWriter.Write(data)
}

func (grw *gzipResponseWriter) WriteString(s string) (int, error) {
    return grw.gzipWriter.Write([]byte(s))
}
```

## Testing Strategy

### Unit Tests

- Request validation logic
- Response formatting consistency
- Middleware chain functionality
- Error handling scenarios
- Sanitization and security validation

### Integration Tests

- End-to-end request processing
- Middleware interaction
- Performance under load
- Security header validation
- CORS compliance

### Security Tests

- Input validation bypass attempts
- XSS and injection protection
- Request size limit enforcement
- Content type validation
- Security header presence

## Configuration

### Environment Variables

```env
# Request Processing Configuration
MAX_REQUEST_SIZE=10485760
REQUEST_TIMEOUT=30s
ENABLE_COMPRESSION=true
COMPRESSION_LEVEL=6
MAX_UPLOAD_SIZE=52428800
ALLOWED_CONTENT_TYPES=application/json,multipart/form-data
ENABLE_REQUEST_LOGGING=true
LOG_REQUEST_BODY=false

# CORS Configuration
CORS_ALLOWED_ORIGINS=*
CORS_ALLOWED_METHODS=GET,POST,PUT,DELETE,OPTIONS
CORS_ALLOWED_HEADERS=Content-Type,Authorization,X-Requested-With
CORS_MAX_AGE=86400

# Validation Configuration
MAX_STRING_LENGTH=10000
MAX_ARRAY_SIZE=1000
STRICT_VALIDATION=true
SANITIZE_INPUT=true
ALLOW_UNKNOWN_FIELDS=false
VALIDATE_EMPTY_STRINGS=true

# Security Configuration
ENABLE_DEBUG_TRACE=false
```

## Dependencies

### External Dependencies

- Gin web framework
- Go validator package
- UUID generation library
- Gzip compression
- Metrics collection system

### Internal Dependencies

- Logging system
- Metrics collection
- Input sanitization framework

## Deliverables

1. **Request Processor:** Complete middleware chain implementation
2. **Response System:** Standardized response formatting
3. **Validation Framework:** Comprehensive input validation
4. **Security Middleware:** Protection against common attacks
5. **Performance Optimization:** Compression and caching headers
6. **Test Suite:** Unit and integration tests
7. **Documentation:** API response formats and error codes

## Definition of Done

- [ ] Request processing pipeline handles all HTTP methods
- [ ] Comprehensive input validation with custom rules
- [ ] Standardized response format across all endpoints
- [ ] Security middleware protects against XSS and injection
- [ ] CORS handling supports multiple origins
- [ ] Request/response compression reduces bandwidth by 60%+
- [ ] Error responses include proper HTTP status codes
- [ ] Pagination support for list endpoints
- [ ] Request logging includes performance metrics
- [ ] File upload handling with size and type validation
- [ ] Request timeout protection prevents resource exhaustion
- [ ] Recovery middleware handles panics gracefully
- [ ] Metrics collection for performance monitoring
- [ ] Unit tests achieve 95%+ coverage
- [ ] Integration tests validate end-to-end processing
- [ ] Security tests verify protection mechanisms
- [ ] Performance tests meet latency requirements
- [ ] Documentation covers all response formats and error codes

---

**Estimated Timeline:** 3 days
**Risk Level:** Medium (comprehensive middleware chain complexity)
**Blockers:** MVP-001 (PostgreSQL Setup), MVP-005 (Journal Service)
**Follow-up Tasks:** MVP-008 (Authenticated API), MVP-013 (Frontend API Integration)
