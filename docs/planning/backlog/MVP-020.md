# MVP-020: Integration Testing Suite

**Task ID:** MVP-020
**Feature Area:** MVP-TEST
**Priority:** P1 (High)
**Effort Estimate:** 4 days
**Dependencies:** MVP-019 (Unit Testing Framework Setup)

## Objective

Implement comprehensive end-to-end integration testing suite that validates complete application workflows, API integrations, and system behavior from user perspective.

## Business Context

Integration tests ensure that all system components work together correctly, preventing regression bugs and validating that user workflows function as expected. This provides confidence in releases and reduces production issues.

## Technical Requirements

### Core Integration Test Areas

1. **API Workflow Testing**

   - Complete authentication flows (JWT, OAuth, OTP)
   - Journal CRUD operations with AI processing
   - User management and profile operations
   - Error handling and edge cases

2. **Database Integration**

   - Transaction integrity across services
   - Data consistency validation
   - Migration testing
   - Performance under load

3. **AI Processing Integration**

   - End-to-end AI processing workflows
   - Worker pool coordination
   - Fallback mechanism validation
   - Processing status tracking

4. **External Service Integration**
   - OpenAI API integration testing
   - Ollama service communication
   - OAuth provider integration
   - Email service validation

## Implementation Specification

### Integration Test Framework

```go
// test/integration/framework.go
package integration

import (
    "context"
    "database/sql"
    "net/http/httptest"
    "testing"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/testcontainers/testcontainers-go/modules/redis"
    "github.com/englog/internal/api"
    "github.com/englog/internal/worker"
)

type IntegrationSuite struct {
    t               *testing.T
    pgContainer     *postgres.PostgresContainer
    redisContainer  *redis.RedisContainer
    db              *sql.DB
    redis           redis.Client
    apiServer       *httptest.Server
    workerService   *worker.Service
    httpClient      *http.Client
    ctx             context.Context
    cleanup         []func()
}

func NewIntegrationSuite(t *testing.T) *IntegrationSuite {
    ctx := context.Background()

    suite := &IntegrationSuite{
        t:       t,
        ctx:     ctx,
        cleanup: make([]func(), 0),
    }

    suite.setupContainers()
    suite.setupServices()
    suite.setupHTTPClient()

    return suite
}

func (s *IntegrationSuite) setupContainers() {
    // PostgreSQL container
    pgContainer, err := postgres.RunContainer(s.ctx,
        testcontainers.WithImage("postgres:15-alpine"),
        postgres.WithDatabase("englog_integration"),
        postgres.WithUsername("testuser"),
        postgres.WithPassword("testpass"),
        testcontainers.WithWaitStrategy(
            wait.ForLog("database system is ready to accept connections").
                WithOccurrence(2).
                WithStartupTimeout(30*time.Second),
        ),
    )
    require.NoError(s.t, err)
    s.pgContainer = pgContainer
    s.addCleanup(func() { pgContainer.Terminate(s.ctx) })

    // Redis container
    redisContainer, err := redis.RunContainer(s.ctx,
        testcontainers.WithImage("redis:7-alpine"),
        testcontainers.WithWaitStrategy(
            wait.ForLog("Ready to accept connections"),
        ),
    )
    require.NoError(s.t, err)
    s.redisContainer = redisContainer
    s.addCleanup(func() { redisContainer.Terminate(s.ctx) })

    // Setup database connection
    dbURL, err := pgContainer.ConnectionString(s.ctx, "sslmode=disable")
    require.NoError(s.t, err)

    s.db, err = sql.Open("postgres", dbURL)
    require.NoError(s.t, err)
    s.addCleanup(func() { s.db.Close() })

    // Setup Redis connection
    redisURL, err := redisContainer.ConnectionString(s.ctx)
    require.NoError(s.t, err)

    opts, err := redis.ParseURL(redisURL)
    require.NoError(s.t, err)
    s.redis = redis.NewClient(opts)
    s.addCleanup(func() { s.redis.Close() })

    // Run database migrations
    err = s.runMigrations()
    require.NoError(s.t, err)
}

func (s *IntegrationSuite) setupServices() {
    // Create API service
    apiConfig := &api.Config{
        Database: s.db,
        Redis:    s.redis,
        JWTSecret: "test-jwt-secret",
        Environment: "integration",
    }

    router := api.NewRouter(apiConfig)
    s.apiServer = httptest.NewServer(router)
    s.addCleanup(func() { s.apiServer.Close() })

    // Create worker service
    workerConfig := &worker.Config{
        Database: s.db,
        Redis:    s.redis,
        APIEndpoint: s.apiServer.URL,
        MockAI: true, // Use mock AI for integration tests
    }

    s.workerService = worker.NewService(workerConfig)
    go s.workerService.Start(s.ctx)
    s.addCleanup(func() { s.workerService.Stop() })

    // Wait for services to be ready
    s.waitForServices()
}

func (s *IntegrationSuite) Cleanup() {
    for i := len(s.cleanup) - 1; i >= 0; i-- {
        s.cleanup[i]()
    }
}

func (s *IntegrationSuite) addCleanup(fn func()) {
    s.cleanup = append(s.cleanup, fn)
}
```

### Authentication Flow Tests

```go
// test/integration/auth_test.go
package integration

import (
    "bytes"
    "encoding/json"
    "net/http"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestAuthenticationFlows(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    t.Run("JWT Authentication Flow", func(t *testing.T) {
        // Step 1: Register user
        registerReq := map[string]string{
            "email": "test@example.com",
            "name":  "Test User",
        }

        resp := suite.makeRequest("POST", "/api/auth/register", registerReq)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)

        var registerResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&registerResp)
        require.NoError(t, err)

        userID := registerResp["user_id"].(string)
        assert.NotEmpty(t, userID)

        // Step 2: Request OTP
        otpReq := map[string]string{
            "email": "test@example.com",
        }

        resp = suite.makeRequest("POST", "/api/auth/otp/request", otpReq)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        // Step 3: Verify OTP (using test OTP)
        verifyReq := map[string]string{
            "email": "test@example.com",
            "code":  "123456", // Test OTP code
        }

        resp = suite.makeRequest("POST", "/api/auth/otp/verify", verifyReq)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var authResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&authResp)
        require.NoError(t, err)

        token := authResp["access_token"].(string)
        refreshToken := authResp["refresh_token"].(string)
        assert.NotEmpty(t, token)
        assert.NotEmpty(t, refreshToken)

        // Step 4: Use token for authenticated request
        resp = suite.makeAuthenticatedRequest("GET", "/api/user/profile", nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var profileResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&profileResp)
        require.NoError(t, err)

        assert.Equal(t, "test@example.com", profileResp["email"])
        assert.Equal(t, "Test User", profileResp["name"])

        // Step 5: Refresh token
        refreshReq := map[string]string{
            "refresh_token": refreshToken,
        }

        resp = suite.makeRequest("POST", "/api/auth/refresh", refreshReq)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var newTokenResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&newTokenResp)
        require.NoError(t, err)

        newToken := newTokenResp["access_token"].(string)
        assert.NotEmpty(t, newToken)
        assert.NotEqual(t, token, newToken)
    })

    t.Run("OAuth Integration Flow", func(t *testing.T) {
        // Mock OAuth callback
        callbackReq := map[string]string{
            "provider": "google",
            "code":     "mock_oauth_code",
            "state":    "mock_state",
        }

        resp := suite.makeRequest("POST", "/api/auth/oauth/callback", callbackReq)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var oauthResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&oauthResp)
        require.NoError(t, err)

        token := oauthResp["access_token"].(string)
        user := oauthResp["user"].(map[string]interface{})

        assert.NotEmpty(t, token)
        assert.Equal(t, "google", user["auth_provider"])
        assert.NotEmpty(t, user["email"])
    })
}
```

### Journal Workflow Tests

```go
// test/integration/journal_test.go
package integration

import (
    "encoding/json"
    "net/http"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestJournalWorkflows(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    // Setup authenticated user
    token := suite.authenticateTestUser("journal-test@example.com", "Journal Test User")

    t.Run("Complete Journal Lifecycle", func(t *testing.T) {
        // Step 1: Create journal entry
        journalReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "title":   "Integration Test Journal",
                "content": "This is a test journal entry for integration testing. I feel excited about testing!",
                "mood":    8,
                "tags":    []string{"testing", "integration", "excitement"},
                "location": map[string]float64{
                    "lat": 40.7128,
                    "lng": -74.0060,
                },
            },
            "entry_type": "text",
        }

        resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)

        var createResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&createResp)
        require.NoError(t, err)

        journalID := createResp["id"].(string)
        assert.NotEmpty(t, journalID)
        assert.Equal(t, "pending", createResp["processing_status"])

        // Step 2: Wait for AI processing to complete
        suite.waitForProcessingComplete(journalID, token, 30*time.Second)

        // Step 3: Retrieve journal with processed content
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var getResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&getResp)
        require.NoError(t, err)

        assert.Equal(t, "completed", getResp["processing_status"])
        assert.NotEmpty(t, getResp["processed_content"])

        processedContent := getResp["processed_content"].([]interface{})
        assert.Greater(t, len(processedContent), 0)

        // Verify sentiment analysis was performed
        foundSentiment := false
        for _, content := range processedContent {
            contentMap := content.(map[string]interface{})
            if contentMap["task_type"] == "sentiment_analysis" {
                foundSentiment = true
                processedData := contentMap["processed_data"].(map[string]interface{})
                assert.Contains(t, processedData, "overall_sentiment")
                break
            }
        }
        assert.True(t, foundSentiment, "Sentiment analysis should be performed")

        // Step 4: Update journal entry
        updateReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "title":   "Updated Integration Test Journal",
                "content": "This is an updated test journal entry. Now I feel even more excited!",
                "mood":    9,
                "tags":    []string{"testing", "integration", "excitement", "updated"},
            },
        }

        resp = suite.makeAuthenticatedRequest("PUT", "/api/journals/"+journalID, updateReq, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        // Step 5: List journals
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals?limit=10&offset=0", nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var listResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&listResp)
        require.NoError(t, err)

        journals := listResp["journals"].([]interface{})
        assert.Greater(t, len(journals), 0)

        // Find our journal in the list
        foundJournal := false
        for _, journal := range journals {
            journalMap := journal.(map[string]interface{})
            if journalMap["id"] == journalID {
                foundJournal = true
                rawData := journalMap["raw_data"].(map[string]interface{})
                assert.Equal(t, "Updated Integration Test Journal", rawData["title"])
                break
            }
        }
        assert.True(t, foundJournal, "Journal should be found in list")

        // Step 6: Delete journal
        resp = suite.makeAuthenticatedRequest("DELETE", "/api/journals/"+journalID, nil, token)
        assert.Equal(t, http.StatusNoContent, resp.StatusCode)

        // Verify deletion
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token)
        assert.Equal(t, http.StatusNotFound, resp.StatusCode)
    })

    t.Run("Concurrent Journal Processing", func(t *testing.T) {
        const numJournals = 5
        journalIDs := make([]string, numJournals)

        // Create multiple journals concurrently
        for i := 0; i < numJournals; i++ {
            journalReq := map[string]interface{}{
                "raw_data": map[string]interface{}{
                    "content": fmt.Sprintf("Concurrent journal entry #%d for stress testing", i+1),
                    "mood":    rand.Intn(10) + 1,
                },
                "entry_type": "text",
            }

            resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
            assert.Equal(t, http.StatusCreated, resp.StatusCode)

            var createResp map[string]interface{}
            err := json.NewDecoder(resp.Body).Decode(&createResp)
            require.NoError(t, err)

            journalIDs[i] = createResp["id"].(string)
        }

        // Wait for all processing to complete
        for _, journalID := range journalIDs {
            suite.waitForProcessingComplete(journalID, token, 60*time.Second)
        }

        // Verify all journals were processed successfully
        for i, journalID := range journalIDs {
            resp := suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token)
            assert.Equal(t, http.StatusOK, resp.StatusCode, "Journal %d should be accessible", i+1)

            var getResp map[string]interface{}
            err := json.NewDecoder(resp.Body).Decode(&getResp)
            require.NoError(t, err)

            assert.Equal(t, "completed", getResp["processing_status"],
                "Journal %d should be processed", i+1)
        }
    })
}
```

### AI Processing Integration Tests

```go
// test/integration/ai_processing_test.go
package integration

import (
    "encoding/json"
    "net/http"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestAIProcessingIntegration(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    token := suite.authenticateTestUser("ai-test@example.com", "AI Test User")

    t.Run("Sentiment Analysis Processing", func(t *testing.T) {
        testCases := []struct {
            name            string
            content         string
            expectedSentiment string
        }{
            {
                name:            "positive content",
                content:         "I had an amazing day today! Everything went perfectly and I feel fantastic!",
                expectedSentiment: "positive",
            },
            {
                name:            "negative content",
                content:         "I'm feeling really down today. Everything seems to be going wrong.",
                expectedSentiment: "negative",
            },
            {
                name:            "neutral content",
                content:         "Today was a regular day. I went to work and came home.",
                expectedSentiment: "neutral",
            },
        }

        for _, tc := range testCases {
            t.Run(tc.name, func(t *testing.T) {
                journalReq := map[string]interface{}{
                    "raw_data": map[string]interface{}{
                        "content": tc.content,
                    },
                    "entry_type": "text",
                }

                resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
                assert.Equal(t, http.StatusCreated, resp.StatusCode)

                var createResp map[string]interface{}
                err := json.NewDecoder(resp.Body).Decode(&createResp)
                require.NoError(t, err)

                journalID := createResp["id"].(string)

                // Wait for processing
                suite.waitForProcessingComplete(journalID, token, 30*time.Second)

                // Check sentiment analysis results
                resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID+"/processed", nil, token)
                assert.Equal(t, http.StatusOK, resp.StatusCode)

                var processedResp map[string]interface{}
                err = json.NewDecoder(resp.Body).Decode(&processedResp)
                require.NoError(t, err)

                processedContent := processedResp["processed_content"].([]interface{})

                foundSentiment := false
                for _, content := range processedContent {
                    contentMap := content.(map[string]interface{})
                    if contentMap["task_type"] == "sentiment_analysis" {
                        foundSentiment = true
                        processedData := contentMap["processed_data"].(map[string]interface{})
                        sentiment := processedData["overall_sentiment"].(map[string]interface{})

                        assert.Equal(t, tc.expectedSentiment, sentiment["label"])
                        assert.Greater(t, contentMap["confidence_score"], 0.7)
                        break
                    }
                }
                assert.True(t, foundSentiment, "Sentiment analysis should be performed")
            })
        }
    })

    t.Run("Processing Pipeline Resilience", func(t *testing.T) {
        // Test processing with very long content
        longContent := strings.Repeat("This is a very long journal entry. ", 1000)

        journalReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "content": longContent,
            },
            "entry_type": "text",
        }

        resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)

        var createResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&createResp)
        require.NoError(t, err)

        journalID := createResp["id"].(string)

        // Wait for processing with longer timeout for large content
        suite.waitForProcessingComplete(journalID, token, 60*time.Second)

        // Verify processing completed successfully
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var getResp map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&getResp)
        require.NoError(t, err)

        assert.Equal(t, "completed", getResp["processing_status"])
    })
}
```

### Database Integration Tests

```go
// test/integration/database_test.go
package integration

import (
    "database/sql"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestDatabaseIntegration(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    t.Run("Transaction Integrity", func(t *testing.T) {
        tx, err := suite.db.Begin()
        require.NoError(t, err)

        // Insert user in transaction
        userID := uuid.New().String()
        _, err = tx.Exec(`
            INSERT INTO users (id, email, name, created_at)
            VALUES ($1, $2, $3, NOW())
        `, userID, "tx-test@example.com", "Transaction Test User")
        require.NoError(t, err)

        // Insert journal in same transaction
        journalID := uuid.New().String()
        _, err = tx.Exec(`
            INSERT INTO journal_entries (id, user_id, raw_data, created_at)
            VALUES ($1, $2, $3, NOW())
        `, journalID, userID, `{"content": "Transaction test journal"}`)
        require.NoError(t, err)

        // Rollback transaction
        err = tx.Rollback()
        require.NoError(t, err)

        // Verify data was not persisted
        var count int
        err = suite.db.QueryRow("SELECT COUNT(*) FROM users WHERE id = $1", userID).Scan(&count)
        require.NoError(t, err)
        assert.Equal(t, 0, count)

        err = suite.db.QueryRow("SELECT COUNT(*) FROM journal_entries WHERE id = $1", journalID).Scan(&count)
        require.NoError(t, err)
        assert.Equal(t, 0, count)
    })

    t.Run("Concurrent Database Access", func(t *testing.T) {
        const numGoroutines = 10
        errors := make(chan error, numGoroutines)

        for i := 0; i < numGoroutines; i++ {
            go func(index int) {
                userID := uuid.New().String()
                email := fmt.Sprintf("concurrent-test-%d@example.com", index)

                _, err := suite.db.Exec(`
                    INSERT INTO users (id, email, name, created_at)
                    VALUES ($1, $2, $3, NOW())
                `, userID, email, fmt.Sprintf("Concurrent User %d", index))

                errors <- err
            }(i)
        }

        // Collect all errors
        for i := 0; i < numGoroutines; i++ {
            err := <-errors
            assert.NoError(t, err, "Concurrent database access should not fail")
        }

        // Verify all users were created
        var count int
        err := suite.db.QueryRow("SELECT COUNT(*) FROM users WHERE email LIKE 'concurrent-test-%'").Scan(&count)
        require.NoError(t, err)
        assert.Equal(t, numGoroutines, count)
    })

    t.Run("Foreign Key Constraints", func(t *testing.T) {
        // Try to insert journal without valid user
        invalidUserID := uuid.New().String()
        journalID := uuid.New().String()

        _, err := suite.db.Exec(`
            INSERT INTO journal_entries (id, user_id, raw_data, created_at)
            VALUES ($1, $2, $3, NOW())
        `, journalID, invalidUserID, `{"content": "Test journal"}`)

        assert.Error(t, err, "Should fail due to foreign key constraint")
        assert.Contains(t, err.Error(), "foreign key constraint")
    })
}
```

### Helper Methods

```go
// test/integration/helpers.go
package integration

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

func (s *IntegrationSuite) makeRequest(method, path string, body interface{}) *http.Response {
    var reqBody *bytes.Buffer
    if body != nil {
        jsonData, _ := json.Marshal(body)
        reqBody = bytes.NewBuffer(jsonData)
    } else {
        reqBody = bytes.NewBuffer(nil)
    }

    req, err := http.NewRequest(method, s.apiServer.URL+path, reqBody)
    require.NoError(s.t, err)

    if body != nil {
        req.Header.Set("Content-Type", "application/json")
    }

    resp, err := s.httpClient.Do(req)
    require.NoError(s.t, err)

    return resp
}

func (s *IntegrationSuite) makeAuthenticatedRequest(method, path string, body interface{}, token string) *http.Response {
    var reqBody *bytes.Buffer
    if body != nil {
        jsonData, _ := json.Marshal(body)
        reqBody = bytes.NewBuffer(jsonData)
    } else {
        reqBody = bytes.NewBuffer(nil)
    }

    req, err := http.NewRequest(method, s.apiServer.URL+path, reqBody)
    require.NoError(s.t, err)

    if body != nil {
        req.Header.Set("Content-Type", "application/json")
    }
    req.Header.Set("Authorization", "Bearer "+token)

    resp, err := s.httpClient.Do(req)
    require.NoError(s.t, err)

    return resp
}

func (s *IntegrationSuite) authenticateTestUser(email, name string) string {
    // Register user
    registerReq := map[string]string{
        "email": email,
        "name":  name,
    }

    resp := s.makeRequest("POST", "/api/auth/register", registerReq)
    require.Equal(s.t, http.StatusCreated, resp.StatusCode)

    // Verify OTP (using test code)
    verifyReq := map[string]string{
        "email": email,
        "code":  "123456",
    }

    resp = s.makeRequest("POST", "/api/auth/otp/verify", verifyReq)
    require.Equal(s.t, http.StatusOK, resp.StatusCode)

    var authResp map[string]interface{}
    err := json.NewDecoder(resp.Body).Decode(&authResp)
    require.NoError(s.t, err)

    return authResp["access_token"].(string)
}

func (s *IntegrationSuite) waitForProcessingComplete(journalID, token string, timeout time.Duration) {
    deadline := time.Now().Add(timeout)

    for time.Now().Before(deadline) {
        resp := s.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token)
        require.Equal(s.t, http.StatusOK, resp.StatusCode)

        var getResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&getResp)
        require.NoError(s.t, err)

        status := getResp["processing_status"].(string)
        if status == "completed" {
            return
        }
        if status == "failed" {
            s.t.Fatalf("Processing failed for journal %s", journalID)
        }

        time.Sleep(1 * time.Second)
    }

    s.t.Fatalf("Processing timeout for journal %s", journalID)
}

func (s *IntegrationSuite) runMigrations() error {
    migrations := []string{
        `CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`,
        `CREATE TABLE IF NOT EXISTS users (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            email VARCHAR(255) UNIQUE NOT NULL,
            name VARCHAR(255),
            auth_provider VARCHAR(50),
            auth_provider_id VARCHAR(255),
            preferences JSONB DEFAULT '{}',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,
        `CREATE TABLE IF NOT EXISTS journal_entries (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            raw_data JSONB NOT NULL,
            entry_type VARCHAR(50) DEFAULT 'text',
            metadata JSONB DEFAULT '{}',
            processing_status VARCHAR(20) DEFAULT 'pending',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,
        `CREATE TABLE IF NOT EXISTS processed_content (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            journal_id UUID NOT NULL REFERENCES journal_entries(id) ON DELETE CASCADE,
            user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            task_type VARCHAR(100) NOT NULL,
            processed_data JSONB NOT NULL,
            confidence_score DECIMAL(3,2),
            ai_provider_info JSONB,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,
        `CREATE INDEX IF NOT EXISTS idx_journal_entries_user_id ON journal_entries(user_id)`,
        `CREATE INDEX IF NOT EXISTS idx_journal_entries_created_at ON journal_entries(created_at)`,
        `CREATE INDEX IF NOT EXISTS idx_processed_content_journal_id ON processed_content(journal_id)`,
    }

    for _, migration := range migrations {
        _, err := s.db.Exec(migration)
        if err != nil {
            return fmt.Errorf("migration failed: %w", err)
        }
    }

    return nil
}

func (s *IntegrationSuite) waitForServices() {
    // Wait for API server to be ready
    maxAttempts := 30
    for i := 0; i < maxAttempts; i++ {
        resp, err := http.Get(s.apiServer.URL + "/health")
        if err == nil && resp.StatusCode == http.StatusOK {
            resp.Body.Close()
            break
        }
        if i == maxAttempts-1 {
            s.t.Fatal("API server failed to start")
        }
        time.Sleep(1 * time.Second)
    }

    // Wait for worker service to be ready
    time.Sleep(2 * time.Second) // Give worker time to connect
}
```

### Test Configuration

```go
// test/integration/config.go
package integration

import (
    "os"
    "testing"
)

func init() {
    // Set test environment variables
    os.Setenv("GIN_MODE", "test")
    os.Setenv("LOG_LEVEL", "error")
    os.Setenv("AI_MOCK_MODE", "true")
    os.Setenv("EMAIL_MOCK_MODE", "true")
    os.Setenv("OAUTH_MOCK_MODE", "true")
}

func TestMain(m *testing.M) {
    // Global setup
    setup()

    // Run tests
    code := m.Run()

    // Global cleanup
    cleanup()

    os.Exit(code)
}

func setup() {
    // Global test setup if needed
}

func cleanup() {
    // Global test cleanup if needed
}
```

### Makefile Integration

```makefile
# Add to project Makefile

.PHONY: test-integration
test-integration:
	@echo "Running integration tests..."
	@go test -v -timeout=300s ./test/integration/...

.PHONY: test-integration-verbose
test-integration-verbose:
	@echo "Running integration tests with verbose output..."
	@go test -v -timeout=300s -race ./test/integration/...

.PHONY: test-integration-coverage
test-integration-coverage:
	@echo "Running integration tests with coverage..."
	@go test -v -timeout=300s -coverprofile=integration.coverage.out ./test/integration/...
	@go tool cover -html=integration.coverage.out -o integration.coverage.html

.PHONY: test-all
test-all: test test-integration
	@echo "All tests completed"
```

## Acceptance Criteria

### Functional Requirements

- [ ] **Complete Authentication Flows**

  - JWT authentication flow working end-to-end
  - OAuth integration flow validated
  - OTP verification process tested
  - Token refresh mechanism validated

- [ ] **Journal Operations**

  - Complete CRUD operations for journals
  - AI processing integration working
  - Concurrent processing handling
  - Error scenarios properly handled

- [ ] **Database Integration**

  - Transaction integrity maintained
  - Foreign key constraints enforced
  - Concurrent access handled correctly
  - Data consistency validated

- [ ] **AI Processing**
  - Sentiment analysis pipeline working
  - Processing status tracking accurate
  - Fallback mechanisms functional
  - Large content handling robust

### Technical Requirements

- [ ] **Test Coverage**

  - All critical user workflows covered
  - Edge cases and error scenarios included
  - Concurrent operations tested
  - Performance under load validated

- [ ] **Test Infrastructure**

  - Isolated test environments
  - Automated test data cleanup
  - Reproducible test results
  - Fast test execution (< 5 minutes total)

- [ ] **Documentation**
  - Test scenarios clearly documented
  - Setup instructions provided
  - Troubleshooting guide available
  - CI/CD integration documented

### Quality Assurance

- [ ] **Reliability**

  - Tests pass consistently
  - No flaky test behavior
  - Proper error handling
  - Comprehensive logging

- [ ] **Maintainability**
  - Clean, readable test code
  - Reusable test utilities
  - Clear test organization
  - Easy to extend and modify

## Dependencies

### Technical Dependencies

- **MVP-019:** Unit Testing Framework Setup (test infrastructure)
- **MVP-001:** PostgreSQL Database Setup (database integration)
- **MVP-002:** Redis Infrastructure (caching integration)
- **MVP-003:** JWT Authentication Service (auth testing)
- **MVP-008:** Authenticated Journal CRUD API (API testing)
- **MVP-009:** gRPC Worker Pool Architecture (worker testing)

### Testing Tools

- **testcontainers-go:** Container management for isolated testing
- **Gin Test Mode:** HTTP testing capabilities
- **testify:** Assertion and testing utilities
- **PostgreSQL Driver:** Database connection testing
- **Redis Client:** Cache integration testing

## Risks and Mitigation

### Technical Risks

1. **Container Startup Time**

   - Risk: Slow test execution due to container overhead
   - Mitigation: Container reuse, parallel execution, optimized images

2. **Test Environment Complexity**

   - Risk: Difficult setup and maintenance
   - Mitigation: Clear documentation, automated setup scripts

3. **Flaky Tests**
   - Risk: Inconsistent test results
   - Mitigation: Proper waiting mechanisms, retry logic, isolated environments

### Operational Risks

1. **CI/CD Integration**

   - Risk: Tests too slow for CI pipeline
   - Mitigation: Parallel execution, test categorization, smart test selection

2. **Resource Requirements**
   - Risk: High memory/CPU usage in CI
   - Mitigation: Container resource limits, test optimization

## Success Metrics

- **Test Coverage:** 100% of critical user workflows covered
- **Test Execution Time:** < 5 minutes for full integration test suite
- **Test Reliability:** 99%+ pass rate on repeated runs
- **Bug Detection:** Integration tests catch 90%+ of workflow regressions

## Future Enhancements

- **Load Testing Integration:** Extend for performance testing
- **Security Testing:** Add security vulnerability scanning
- **Cross-Browser Testing:** Frontend integration testing
- **Mobile Testing:** Mobile app integration testing
