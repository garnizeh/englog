# MVP-006: User Service & Management

**Feature:** MVP-Backend
**Priority:** P0 (Critical)
**Effort:** Medium (3 days)
**Dependencies:** MVP-003 (JWT Authentication)

## Objective

Implement comprehensive user management services including profile management, preferences, settings, and user lifecycle operations with secure data handling and GDPR compliance preparation.

## Technical Scope

### User Management Operations

- User profile CRUD operations
- Preference and settings management
- Account lifecycle (activation, suspension, deletion)
- User analytics and statistics
- Data export and privacy controls

### Security & Privacy

- User data isolation enforcement
- GDPR compliance preparation
- Data export and deletion workflows
- Activity logging and audit trails
- Secure preference storage

### Performance & Caching

- User profile caching strategies
- Preference caching for quick access
- Session invalidation management
- Optimized user data retrieval

## Acceptance Criteria

### User Profile Management

- [ ] Retrieve and update user profiles with validation
- [ ] Manage user preferences with type safety
- [ ] Handle profile picture uploads and management
- [ ] Support timezone and language settings
- [ ] Track user activity and engagement metrics

### Account Management

- [ ] Activate/deactivate user accounts
- [ ] Soft delete accounts with data retention
- [ ] Export user data in machine-readable format
- [ ] Purge user data completely (GDPR compliance)
- [ ] Password change and security settings management

### Performance Requirements

- [ ] User profile operations complete under 100ms
- [ ] Preferences cached for quick access
- [ ] Bulk operations handle 1000+ users efficiently
- [ ] User search with pagination and filtering
- [ ] Session management with Redis optimization

## Implementation Details

### User Service Interface

```go
type UserService interface {
    // Profile management
    GetUserProfile(ctx context.Context, userID string) (*UserProfile, error)
    UpdateUserProfile(ctx context.Context, userID string, req *UpdateProfileRequest) (*UserProfile, error)
    UploadProfilePicture(ctx context.Context, userID string, file io.Reader, filename string) (*ProfilePicture, error)
    DeleteProfilePicture(ctx context.Context, userID string) error

    // Preferences and settings
    GetUserPreferences(ctx context.Context, userID string) (*UserPreferences, error)
    UpdateUserPreferences(ctx context.Context, userID string, req *UpdatePreferencesRequest) (*UserPreferences, error)
    ResetPreferences(ctx context.Context, userID string) (*UserPreferences, error)

    // Account management
    GetUserStats(ctx context.Context, userID string) (*UserStats, error)
    UpdateUserStatus(ctx context.Context, userID string, status UserStatus) error
    DeactivateUser(ctx context.Context, userID string, reason string) error
    ReactivateUser(ctx context.Context, userID string) error

    // Data management
    ExportUserData(ctx context.Context, userID string) (*UserDataExport, error)
    InitiateDataDeletion(ctx context.Context, userID string, reason string) error
    PurgeUserData(ctx context.Context, userID string) error

    // Search and analytics
    SearchUsers(ctx context.Context, req *SearchUsersRequest) (*UserSearchResults, error)
    GetUserActivity(ctx context.Context, userID string, days int) (*UserActivity, error)
    GetSystemStats(ctx context.Context) (*SystemStats, error)

    // Session management
    InvalidateUserSessions(ctx context.Context, userID string) error
    GetActiveSessions(ctx context.Context, userID string) ([]*UserSession, error)
    RevokeSession(ctx context.Context, userID, sessionID string) error
}

type UserServiceImpl struct {
    userRepo       UserRepository
    sessionRepo    SessionRepository
    journalRepo    JournalRepository
    cache          CacheService
    storage        FileStorage
    validator      *Validator
    eventPublisher EventPublisher
    logger         *slog.Logger
    config         UserServiceConfig
    metrics        *UserServiceMetrics
}

type UserServiceConfig struct {
    ProfileCacheTTL           time.Duration `env:"PROFILE_CACHE_TTL" default:"30m"`
    PreferencesCacheTTL       time.Duration `env:"PREFERENCES_CACHE_TTL" default:"1h"`
    MaxProfilePictureSize     int64         `env:"MAX_PROFILE_PICTURE_SIZE" default:"5242880"` // 5MB
    AllowedImageTypes         []string      `env:"ALLOWED_IMAGE_TYPES" default:"jpg,jpeg,png,webp"`
    DataExportTimeout         time.Duration `env:"DATA_EXPORT_TIMEOUT" default:"30m"`
    MaxSearchResults          int           `env:"MAX_SEARCH_RESULTS" default:"100"`
    ActivityRetentionDays     int           `env:"ACTIVITY_RETENTION_DAYS" default:"90"`
    EnableDataExportEncryption bool         `env:"ENABLE_DATA_EXPORT_ENCRYPTION" default:"true"`
}

type UserProfile struct {
    ID              string                 `json:"id"`
    Email           string                 `json:"email"`
    Name            string                 `json:"name"`
    DisplayName     *string                `json:"display_name"`
    Bio             *string                `json:"bio"`
    ProfilePicture  *ProfilePicture        `json:"profile_picture"`
    Timezone        string                 `json:"timezone"`
    Language        string                 `json:"language"`
    Status          UserStatus             `json:"status"`
    EmailVerified   bool                   `json:"email_verified"`
    CreatedAt       time.Time              `json:"created_at"`
    UpdatedAt       time.Time              `json:"updated_at"`
    LastActiveAt    *time.Time             `json:"last_active_at"`
    LoginCount      int                    `json:"login_count"`
    CustomFields    map[string]any `json:"custom_fields,omitempty"`
}

type ProfilePicture struct {
    ID       string    `json:"id"`
    URL      string    `json:"url"`
    ThumbnailURL string `json:"thumbnail_url"`
    Filename string    `json:"filename"`
    Size     int64     `json:"size"`
    MimeType string    `json:"mime_type"`
    UploadedAt time.Time `json:"uploaded_at"`
}

type UserPreferences struct {
    UserID                    string                 `json:"user_id"`
    Timezone                  string                 `json:"timezone"`
    Language                  string                 `json:"language"`
    DateFormat                string                 `json:"date_format"`
    TimeFormat                string                 `json:"time_format"`
    Theme                     string                 `json:"theme"`

    // Notification preferences
    EmailNotifications        bool                   `json:"email_notifications"`
    ProcessingNotifications   bool                   `json:"processing_notifications"`
    WeeklyDigest              bool                   `json:"weekly_digest"`
    MonthlyReport             bool                   `json:"monthly_report"`

    // AI Processing preferences
    AIProcessingEnabled       bool                   `json:"ai_processing_enabled"`
    PreferredAIProvider       string                 `json:"preferred_ai_provider"`
    ProcessingDepth           string                 `json:"processing_depth"` // "basic", "standard", "detailed"
    AutoTagging               bool                   `json:"auto_tagging"`
    SentimentTracking         bool                   `json:"sentiment_tracking"`

    // Privacy preferences
    DataSharingOptIn          bool                   `json:"data_sharing_opt_in"`
    AnonymousAnalytics        bool                   `json:"anonymous_analytics"`
    ActivityTracking          bool                   `json:"activity_tracking"`

    // Journal preferences
    DefaultJournalVisibility  string                 `json:"default_journal_visibility"`
    AutoSave                  bool                   `json:"auto_save"`
    AutoSaveInterval          int                    `json:"auto_save_interval"` // seconds

    // Data retention
    DataRetentionYears        *int                   `json:"data_retention_years,omitempty"`
    AutoDeleteOldEntries      bool                   `json:"auto_delete_old_entries"`

    CustomPreferences         map[string]any `json:"custom_preferences,omitempty"`
    UpdatedAt                 time.Time              `json:"updated_at"`
}

type UserStats struct {
    UserID                string    `json:"user_id"`
    TotalJournals         int       `json:"total_journals"`
    TotalWords            int       `json:"total_words"`
    AverageWordsPerEntry  float64   `json:"average_words_per_entry"`
    EntriesThisWeek       int       `json:"entries_this_week"`
    EntriesThisMonth      int       `json:"entries_this_month"`
    LongestStreak         int       `json:"longest_streak_days"`
    CurrentStreak         int       `json:"current_streak_days"`
    FirstEntryDate        *time.Time `json:"first_entry_date"`
    LastEntryDate         *time.Time `json:"last_entry_date"`
    ProcessedEntries      int       `json:"processed_entries"`
    PendingProcessing     int       `json:"pending_processing"`
    FavoriteWritingTime   *string   `json:"favorite_writing_time,omitempty"`
    MostProductiveDay     *string   `json:"most_productive_day,omitempty"`
    AverageMoodScore      *float64  `json:"average_mood_score,omitempty"`
    TopTags               []string  `json:"top_tags,omitempty"`
}

type UserStatus string

const (
    UserStatusActive    UserStatus = "active"
    UserStatusInactive  UserStatus = "inactive"
    UserStatusSuspended UserStatus = "suspended"
    UserStatusDeleted   UserStatus = "deleted"
    UserStatusPending   UserStatus = "pending"
)

func NewUserService(
    userRepo UserRepository,
    sessionRepo SessionRepository,
    journalRepo JournalRepository,
    cache CacheService,
    storage FileStorage,
    validator *Validator,
    eventPublisher EventPublisher,
    logger *slog.Logger,
    config UserServiceConfig,
) *UserServiceImpl {
    return &UserServiceImpl{
        userRepo:       userRepo,
        sessionRepo:    sessionRepo,
        journalRepo:    journalRepo,
        cache:          cache,
        storage:        storage,
        validator:      validator,
        eventPublisher: eventPublisher,
        logger:         logger,
        config:         config,
        metrics:        NewUserServiceMetrics(),
    }
}
```

### Profile Management

```go
func (s *UserServiceImpl) GetUserProfile(ctx context.Context, userID string) (*UserProfile, error) {
    start := time.Now()
    defer func() {
        s.metrics.OperationDuration.WithLabelValues("get_profile").Observe(time.Since(start).Seconds())
    }()

    // Try cache first
    cacheKey := s.buildProfileCacheKey(userID)
    var profile UserProfile

    if err := s.cache.Get(ctx, cacheKey, &profile); err == nil {
        s.metrics.CacheHits.Inc()
        return &profile, nil
    }

    s.metrics.CacheMisses.Inc()

    // Fetch from database
    user, err := s.userRepo.GetByID(ctx, userID)
    if err != nil {
        if err == ErrUserNotFound {
            return nil, err
        }
        s.metrics.DatabaseErrors.Inc()
        return nil, fmt.Errorf("failed to get user: %w", err)
    }

    // Convert to profile
    profile = s.userToProfile(user)

    // Cache the profile
    s.cache.Set(ctx, cacheKey, &profile, s.config.ProfileCacheTTL)

    return &profile, nil
}

func (s *UserServiceImpl) UpdateUserProfile(ctx context.Context, userID string, req *UpdateProfileRequest) (*UserProfile, error) {
    start := time.Now()
    defer func() {
        s.metrics.OperationDuration.WithLabelValues("update_profile").Observe(time.Since(start).Seconds())
    }()

    s.logger.Info("Updating user profile", "user_id", userID)

    // Validate request
    if err := s.validator.validate.Struct(req); err != nil {
        s.metrics.ValidationErrors.Inc()
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // Get current user
    user, err := s.userRepo.GetByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }

    // Track what changed
    changes := make(map[string]any)

    // Apply updates
    if req.Name != nil && *req.Name != user.Name {
        sanitized := s.validator.sanitizer.Sanitize(*req.Name)
        if sanitized == "" {
            return nil, ErrInvalidName
        }
        changes["name"] = user.Name
        user.Name = sanitized
    }

    if req.DisplayName != nil {
        sanitized := s.validator.sanitizer.Sanitize(*req.DisplayName)
        if sanitized == "" {
            user.DisplayName = nil
        } else {
            user.DisplayName = &sanitized
        }
        changes["display_name"] = req.DisplayName
    }

    if req.Bio != nil {
        sanitized := s.validator.sanitizer.Sanitize(*req.Bio)
        if len(sanitized) > 500 {
            return nil, ErrBioTooLong
        }
        if sanitized == "" {
            user.Bio = nil
        } else {
            user.Bio = &sanitized
        }
        changes["bio"] = req.Bio
    }

    if req.Timezone != nil && *req.Timezone != user.Timezone {
        if !s.isValidTimezone(*req.Timezone) {
            return nil, ErrInvalidTimezone
        }
        changes["timezone"] = user.Timezone
        user.Timezone = *req.Timezone
    }

    if req.Language != nil && *req.Language != user.Language {
        if !s.isValidLanguage(*req.Language) {
            return nil, ErrInvalidLanguage
        }
        changes["language"] = user.Language
        user.Language = *req.Language
    }

    if req.CustomFields != nil {
        // Validate custom fields
        if err := s.validateCustomFields(req.CustomFields); err != nil {
            return nil, err
        }

        if user.CustomFields == nil {
            user.CustomFields = make(map[string]any)
        }

        for k, v := range req.CustomFields {
            user.CustomFields[k] = v
        }
        changes["custom_fields"] = req.CustomFields
    }

    // Update timestamp
    user.UpdatedAt = time.Now()

    // Save to database
    if err := s.userRepo.Update(ctx, user); err != nil {
        s.metrics.DatabaseErrors.Inc()
        return nil, fmt.Errorf("failed to update user: %w", err)
    }

    // Convert to profile
    profile := s.userToProfile(user)

    // Update cache
    cacheKey := s.buildProfileCacheKey(userID)
    s.cache.Set(ctx, cacheKey, &profile, s.config.ProfileCacheTTL)

    // Invalidate related caches
    s.invalidateUserCaches(userID)

    // Publish profile updated event
    if len(changes) > 0 {
        event := &UserProfileUpdatedEvent{
            UserID:    userID,
            Changes:   changes,
            UpdatedAt: user.UpdatedAt,
        }

        if err := s.eventPublisher.PublishUserProfileUpdated(ctx, event); err != nil {
            s.logger.Warn("Failed to publish profile updated event",
                "user_id", userID,
                "error", err)
        }
    }

    s.metrics.ProfilesUpdated.Inc()
    s.logger.Info("User profile updated successfully", "user_id", userID)

    return &profile, nil
}

func (s *UserServiceImpl) UploadProfilePicture(ctx context.Context, userID string, file io.Reader, filename string) (*ProfilePicture, error) {
    start := time.Now()
    defer func() {
        s.metrics.OperationDuration.WithLabelValues("upload_picture").Observe(time.Since(start).Seconds())
    }()

    s.logger.Info("Uploading profile picture", "user_id", userID, "filename", filename)

    // Validate file type
    ext := strings.ToLower(filepath.Ext(filename))
    if ext != "" {
        ext = ext[1:] // Remove the dot
    }

    if !s.isAllowedImageType(ext) {
        return nil, ErrInvalidImageType
    }

    // Read file into memory (with size limit)
    limitedReader := io.LimitReader(file, s.config.MaxProfilePictureSize)
    fileData, err := io.ReadAll(limitedReader)
    if err != nil {
        return nil, fmt.Errorf("failed to read file: %w", err)
    }

    if int64(len(fileData)) >= s.config.MaxProfilePictureSize {
        return nil, ErrFileTooLarge
    }

    // Validate image format
    mimeType := http.DetectContentType(fileData)
    if !strings.HasPrefix(mimeType, "image/") {
        return nil, ErrInvalidImageType
    }

    // Generate unique filename
    pictureID := uuid.New().String()
    storagePath := fmt.Sprintf("profile-pictures/%s/%s%s", userID, pictureID, ext)

    // Upload to storage
    uploadResult, err := s.storage.Upload(ctx, storagePath, bytes.NewReader(fileData), mimeType)
    if err != nil {
        return nil, fmt.Errorf("failed to upload file: %w", err)
    }

    // Generate thumbnail (optional, depends on storage service capabilities)
    thumbnailPath := fmt.Sprintf("profile-pictures/%s/%s_thumb%s", userID, pictureID, ext)
    thumbnailURL, err := s.generateThumbnail(ctx, fileData, thumbnailPath, mimeType)
    if err != nil {
        s.logger.Warn("Failed to generate thumbnail", "error", err)
        thumbnailURL = uploadResult.URL // Fallback to original
    }

    // Create profile picture record
    profilePicture := &ProfilePicture{
        ID:           pictureID,
        URL:          uploadResult.URL,
        ThumbnailURL: thumbnailURL,
        Filename:     filename,
        Size:         int64(len(fileData)),
        MimeType:     mimeType,
        UploadedAt:   time.Now(),
    }

    // Update user record
    user, err := s.userRepo.GetByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }

    // Delete old profile picture if exists
    if user.ProfilePictureID != nil {
        oldPicture, _ := s.userRepo.GetProfilePicture(ctx, *user.ProfilePictureID)
        if oldPicture != nil {
            s.deleteProfilePictureFile(ctx, oldPicture)
        }
    }

    // Save profile picture
    if err := s.userRepo.SaveProfilePicture(ctx, userID, profilePicture); err != nil {
        // Clean up uploaded file
        s.storage.Delete(ctx, storagePath)
        if thumbnailURL != uploadResult.URL {
            s.storage.Delete(ctx, thumbnailPath)
        }
        return nil, fmt.Errorf("failed to save profile picture: %w", err)
    }

    // Update cache
    s.invalidateUserCaches(userID)

    s.metrics.ProfilePicturesUploaded.Inc()
    s.logger.Info("Profile picture uploaded successfully",
        "user_id", userID,
        "picture_id", pictureID,
        "size", len(fileData))

    return profilePicture, nil
}
```

### Preferences Management

```go
func (s *UserServiceImpl) GetUserPreferences(ctx context.Context, userID string) (*UserPreferences, error) {
    // Try cache first
    cacheKey := s.buildPreferencesCacheKey(userID)
    var prefs UserPreferences

    if err := s.cache.Get(ctx, cacheKey, &prefs); err == nil {
        s.metrics.CacheHits.Inc()
        return &prefs, nil
    }

    s.metrics.CacheMisses.Inc()

    // Get from database or create defaults
    preferences, err := s.userRepo.GetUserPreferences(ctx, userID)
    if err != nil {
        if err == ErrPreferencesNotFound {
            // Create default preferences
            preferences = s.createDefaultPreferences(userID)
            if err := s.userRepo.SaveUserPreferences(ctx, preferences); err != nil {
                return nil, fmt.Errorf("failed to save default preferences: %w", err)
            }
        } else {
            return nil, fmt.Errorf("failed to get preferences: %w", err)
        }
    }

    // Cache preferences
    s.cache.Set(ctx, cacheKey, preferences, s.config.PreferencesCacheTTL)

    return preferences, nil
}

func (s *UserServiceImpl) UpdateUserPreferences(ctx context.Context, userID string, req *UpdatePreferencesRequest) (*UserPreferences, error) {
    start := time.Now()
    defer func() {
        s.metrics.OperationDuration.WithLabelValues("update_preferences").Observe(time.Since(start).Seconds())
    }()

    s.logger.Info("Updating user preferences", "user_id", userID)

    // Validate request
    if err := s.validator.validate.Struct(req); err != nil {
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // Get current preferences
    current, err := s.GetUserPreferences(ctx, userID)
    if err != nil {
        return nil, err
    }

    // Track changes for audit
    changes := make(map[string]any)

    // Apply updates
    if req.Timezone != nil && *req.Timezone != current.Timezone {
        if !s.isValidTimezone(*req.Timezone) {
            return nil, ErrInvalidTimezone
        }
        changes["timezone"] = current.Timezone
        current.Timezone = *req.Timezone
    }

    if req.Language != nil && *req.Language != current.Language {
        if !s.isValidLanguage(*req.Language) {
            return nil, ErrInvalidLanguage
        }
        changes["language"] = current.Language
        current.Language = *req.Language
    }

    if req.DateFormat != nil && *req.DateFormat != current.DateFormat {
        if !s.isValidDateFormat(*req.DateFormat) {
            return nil, ErrInvalidDateFormat
        }
        changes["date_format"] = current.DateFormat
        current.DateFormat = *req.DateFormat
    }

    if req.TimeFormat != nil && *req.TimeFormat != current.TimeFormat {
        if !s.isValidTimeFormat(*req.TimeFormat) {
            return nil, ErrInvalidTimeFormat
        }
        changes["time_format"] = current.TimeFormat
        current.TimeFormat = *req.TimeFormat
    }

    if req.Theme != nil && *req.Theme != current.Theme {
        if !s.isValidTheme(*req.Theme) {
            return nil, ErrInvalidTheme
        }
        changes["theme"] = current.Theme
        current.Theme = *req.Theme
    }

    // Notification preferences
    if req.EmailNotifications != nil && *req.EmailNotifications != current.EmailNotifications {
        changes["email_notifications"] = current.EmailNotifications
        current.EmailNotifications = *req.EmailNotifications
    }

    if req.ProcessingNotifications != nil && *req.ProcessingNotifications != current.ProcessingNotifications {
        changes["processing_notifications"] = current.ProcessingNotifications
        current.ProcessingNotifications = *req.ProcessingNotifications
    }

    if req.WeeklyDigest != nil && *req.WeeklyDigest != current.WeeklyDigest {
        changes["weekly_digest"] = current.WeeklyDigest
        current.WeeklyDigest = *req.WeeklyDigest
    }

    if req.MonthlyReport != nil && *req.MonthlyReport != current.MonthlyReport {
        changes["monthly_report"] = current.MonthlyReport
        current.MonthlyReport = *req.MonthlyReport
    }

    // AI Processing preferences
    if req.AIProcessingEnabled != nil && *req.AIProcessingEnabled != current.AIProcessingEnabled {
        changes["ai_processing_enabled"] = current.AIProcessingEnabled
        current.AIProcessingEnabled = *req.AIProcessingEnabled
    }

    if req.PreferredAIProvider != nil && *req.PreferredAIProvider != current.PreferredAIProvider {
        if !s.isValidAIProvider(*req.PreferredAIProvider) {
            return nil, ErrInvalidAIProvider
        }
        changes["preferred_ai_provider"] = current.PreferredAIProvider
        current.PreferredAIProvider = *req.PreferredAIProvider
    }

    if req.ProcessingDepth != nil && *req.ProcessingDepth != current.ProcessingDepth {
        if !s.isValidProcessingDepth(*req.ProcessingDepth) {
            return nil, ErrInvalidProcessingDepth
        }
        changes["processing_depth"] = current.ProcessingDepth
        current.ProcessingDepth = *req.ProcessingDepth
    }

    if req.AutoTagging != nil && *req.AutoTagging != current.AutoTagging {
        changes["auto_tagging"] = current.AutoTagging
        current.AutoTagging = *req.AutoTagging
    }

    if req.SentimentTracking != nil && *req.SentimentTracking != current.SentimentTracking {
        changes["sentiment_tracking"] = current.SentimentTracking
        current.SentimentTracking = *req.SentimentTracking
    }

    // Privacy preferences
    if req.DataSharingOptIn != nil && *req.DataSharingOptIn != current.DataSharingOptIn {
        changes["data_sharing_opt_in"] = current.DataSharingOptIn
        current.DataSharingOptIn = *req.DataSharingOptIn
    }

    if req.AnonymousAnalytics != nil && *req.AnonymousAnalytics != current.AnonymousAnalytics {
        changes["anonymous_analytics"] = current.AnonymousAnalytics
        current.AnonymousAnalytics = *req.AnonymousAnalytics
    }

    if req.ActivityTracking != nil && *req.ActivityTracking != current.ActivityTracking {
        changes["activity_tracking"] = current.ActivityTracking
        current.ActivityTracking = *req.ActivityTracking
    }

    // Journal preferences
    if req.DefaultJournalVisibility != nil && *req.DefaultJournalVisibility != current.DefaultJournalVisibility {
        if !s.isValidVisibility(*req.DefaultJournalVisibility) {
            return nil, ErrInvalidVisibility
        }
        changes["default_journal_visibility"] = current.DefaultJournalVisibility
        current.DefaultJournalVisibility = *req.DefaultJournalVisibility
    }

    if req.AutoSave != nil && *req.AutoSave != current.AutoSave {
        changes["auto_save"] = current.AutoSave
        current.AutoSave = *req.AutoSave
    }

    if req.AutoSaveInterval != nil && *req.AutoSaveInterval != current.AutoSaveInterval {
        if *req.AutoSaveInterval < 10 || *req.AutoSaveInterval > 300 {
            return nil, ErrInvalidAutoSaveInterval
        }
        changes["auto_save_interval"] = current.AutoSaveInterval
        current.AutoSaveInterval = *req.AutoSaveInterval
    }

    // Data retention
    if req.DataRetentionYears != nil {
        if *req.DataRetentionYears != nil && (**req.DataRetentionYears < 1 || **req.DataRetentionYears > 50) {
            return nil, ErrInvalidDataRetention
        }
        changes["data_retention_years"] = current.DataRetentionYears
        current.DataRetentionYears = *req.DataRetentionYears
    }

    if req.AutoDeleteOldEntries != nil && *req.AutoDeleteOldEntries != current.AutoDeleteOldEntries {
        changes["auto_delete_old_entries"] = current.AutoDeleteOldEntries
        current.AutoDeleteOldEntries = *req.AutoDeleteOldEntries
    }

    // Custom preferences
    if req.CustomPreferences != nil {
        if err := s.validateCustomPreferences(req.CustomPreferences); err != nil {
            return nil, err
        }

        if current.CustomPreferences == nil {
            current.CustomPreferences = make(map[string]any)
        }

        for k, v := range req.CustomPreferences {
            current.CustomPreferences[k] = v
        }
        changes["custom_preferences"] = req.CustomPreferences
    }

    // Update timestamp
    current.UpdatedAt = time.Now()

    // Save to database
    if err := s.userRepo.SaveUserPreferences(ctx, current); err != nil {
        s.metrics.DatabaseErrors.Inc()
        return nil, fmt.Errorf("failed to save preferences: %w", err)
    }

    // Update cache
    cacheKey := s.buildPreferencesCacheKey(userID)
    s.cache.Set(ctx, cacheKey, current, s.config.PreferencesCacheTTL)

    // Publish preferences updated event
    if len(changes) > 0 {
        event := &UserPreferencesUpdatedEvent{
            UserID:    userID,
            Changes:   changes,
            UpdatedAt: current.UpdatedAt,
        }

        if err := s.eventPublisher.PublishUserPreferencesUpdated(ctx, event); err != nil {
            s.logger.Warn("Failed to publish preferences updated event",
                "user_id", userID,
                "error", err)
        }
    }

    s.metrics.PreferencesUpdated.Inc()
    s.logger.Info("User preferences updated successfully", "user_id", userID)

    return current, nil
}

func (s *UserServiceImpl) createDefaultPreferences(userID string) *UserPreferences {
    return &UserPreferences{
        UserID:                   userID,
        Timezone:                 "UTC",
        Language:                 "en",
        DateFormat:               "YYYY-MM-DD",
        TimeFormat:               "24h",
        Theme:                    "system",
        EmailNotifications:       true,
        ProcessingNotifications:  true,
        WeeklyDigest:             true,
        MonthlyReport:            true,
        AIProcessingEnabled:      true,
        PreferredAIProvider:      "openai",
        ProcessingDepth:          "standard",
        AutoTagging:              true,
        SentimentTracking:        true,
        DataSharingOptIn:         false,
        AnonymousAnalytics:       true,
        ActivityTracking:         true,
        DefaultJournalVisibility: "private",
        AutoSave:                 true,
        AutoSaveInterval:         30,
        AutoDeleteOldEntries:     false,
        CustomPreferences:        make(map[string]any),
        UpdatedAt:                time.Now(),
    }
}
```

### Data Export and GDPR Compliance

```go
func (s *UserServiceImpl) ExportUserData(ctx context.Context, userID string) (*UserDataExport, error) {
    start := time.Now()
    defer func() {
        s.metrics.OperationDuration.WithLabelValues("export_data").Observe(time.Since(start).Seconds())
    }()

    s.logger.Info("Starting user data export", "user_id", userID)

    // Create export context with timeout
    exportCtx, cancel := context.WithTimeout(ctx, s.config.DataExportTimeout)
    defer cancel()

    // Collect all user data
    export := &UserDataExport{
        UserID:      userID,
        RequestedAt: time.Now(),
        Format:      "json",
    }

    // Get user profile
    profile, err := s.GetUserProfile(exportCtx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to export profile: %w", err)
    }
    export.Profile = profile

    // Get user preferences
    preferences, err := s.GetUserPreferences(exportCtx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to export preferences: %w", err)
    }
    export.Preferences = preferences

    // Get all journal entries
    journals, err := s.journalRepo.GetAllByUserID(exportCtx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to export journals: %w", err)
    }
    export.Journals = journals

    // Get all processed content
    processedContent, err := s.journalRepo.GetAllProcessedContentByUser(exportCtx, userID)
    if err != nil {
        s.logger.Warn("Failed to export processed content", "error", err)
        // Continue with export even if processed content fails
    }
    export.ProcessedContent = processedContent

    // Get user sessions
    sessions, err := s.sessionRepo.GetByUserID(exportCtx, userID)
    if err != nil {
        s.logger.Warn("Failed to export sessions", "error", err)
        // Continue with export even if sessions fail
    }
    export.Sessions = sessions

    // Get activity logs
    activity, err := s.getUserActivityLogs(exportCtx, userID)
    if err != nil {
        s.logger.Warn("Failed to export activity logs", "error", err)
        // Continue with export even if activity fails
    }
    export.ActivityLogs = activity

    // Calculate export size
    exportData, err := json.Marshal(export)
    if err != nil {
        return nil, fmt.Errorf("failed to serialize export: %w", err)
    }
    export.SizeBytes = int64(len(exportData))

    // Encrypt export if enabled
    if s.config.EnableDataExportEncryption {
        encryptedData, err := s.encryptExportData(exportData, userID)
        if err != nil {
            return nil, fmt.Errorf("failed to encrypt export: %w", err)
        }
        export.EncryptedData = encryptedData
        export.Encrypted = true
    } else {
        export.Data = exportData
        export.Encrypted = false
    }

    // Store export temporarily for download
    exportID := uuid.New().String()
    export.ExportID = exportID

    if err := s.storeDataExport(exportCtx, export); err != nil {
        return nil, fmt.Errorf("failed to store export: %w", err)
    }

    // Log GDPR export request
    s.logGDPRAction(userID, "data_export", exportID)

    s.metrics.DataExportsGenerated.Inc()
    s.logger.Info("User data export completed",
        "user_id", userID,
        "export_id", exportID,
        "size_mb", export.SizeBytes/1024/1024)

    return export, nil
}

func (s *UserServiceImpl) InitiateDataDeletion(ctx context.Context, userID string, reason string) error {
    s.logger.Info("Initiating user data deletion",
        "user_id", userID,
        "reason", reason)

    // Verify user exists
    user, err := s.userRepo.GetByID(ctx, userID)
    if err != nil {
        return fmt.Errorf("failed to get user: %w", err)
    }

    // Create deletion request
    deletionRequest := &DataDeletionRequest{
        ID:          uuid.New().String(),
        UserID:      userID,
        Reason:      reason,
        Status:      "pending",
        RequestedAt: time.Now(),
        ScheduledAt: time.Now().Add(30 * 24 * time.Hour), // 30 day grace period
    }

    // Save deletion request
    if err := s.userRepo.SaveDeletionRequest(ctx, deletionRequest); err != nil {
        return fmt.Errorf("failed to save deletion request: %w", err)
    }

    // Mark user as pending deletion
    if err := s.UpdateUserStatus(ctx, userID, UserStatusPending); err != nil {
        return fmt.Errorf("failed to update user status: %w", err)
    }

    // Log GDPR deletion request
    s.logGDPRAction(userID, "deletion_requested", deletionRequest.ID)

    // Publish deletion scheduled event
    event := &UserDeletionScheduledEvent{
        UserID:      userID,
        DeletionID:  deletionRequest.ID,
        ScheduledAt: deletionRequest.ScheduledAt,
        Reason:      reason,
    }

    if err := s.eventPublisher.PublishUserDeletionScheduled(ctx, event); err != nil {
        s.logger.Warn("Failed to publish deletion scheduled event",
            "user_id", userID,
            "error", err)
    }

    s.metrics.DeletionRequestsInitiated.Inc()
    return nil
}

func (s *UserServiceImpl) PurgeUserData(ctx context.Context, userID string) error {
    s.logger.Info("Purging all user data", "user_id", userID)

    // Start transaction for data purge
    tx, err := s.userRepo.BeginTx(ctx)
    if err != nil {
        return fmt.Errorf("failed to start purge transaction: %w", err)
    }
    defer tx.Rollback()

    // Delete in correct order to respect foreign key constraints

    // 1. Delete processed content
    if err := s.journalRepo.DeleteAllProcessedContentByUserWithTx(ctx, tx, userID); err != nil {
        return fmt.Errorf("failed to delete processed content: %w", err)
    }

    // 2. Delete journal entries
    if err := s.journalRepo.DeleteAllByUserIDWithTx(ctx, tx, userID); err != nil {
        return fmt.Errorf("failed to delete journals: %w", err)
    }

    // 3. Delete user sessions
    if err := s.sessionRepo.DeleteAllByUserIDWithTx(ctx, tx, userID); err != nil {
        return fmt.Errorf("failed to delete sessions: %w", err)
    }

    // 4. Delete profile picture files
    if err := s.deleteUserProfilePictures(ctx, userID); err != nil {
        s.logger.Warn("Failed to delete profile pictures", "error", err)
        // Continue with purge even if file deletion fails
    }

    // 5. Anonymize user record (keep for audit trail)
    if err := s.userRepo.AnonymizeUserWithTx(ctx, tx, userID); err != nil {
        return fmt.Errorf("failed to anonymize user: %w", err)
    }

    // Commit transaction
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit purge transaction: %w", err)
    }

    // Clear all caches
    s.invalidateAllUserCaches(userID)

    // Log GDPR purge completion
    s.logGDPRAction(userID, "data_purged", "")

    // Publish user purged event
    event := &UserDataPurgedEvent{
        UserID:   userID,
        PurgedAt: time.Now(),
    }

    if err := s.eventPublisher.PublishUserDataPurged(ctx, event); err != nil {
        s.logger.Warn("Failed to publish user purged event",
            "user_id", userID,
            "error", err)
    }

    s.metrics.UsersPurged.Inc()
    s.logger.Info("User data purged successfully", "user_id", userID)

    return nil
}
```

### Helper Functions

```go
func (s *UserServiceImpl) userToProfile(user *User) UserProfile {
    profile := UserProfile{
        ID:            user.ID,
        Email:         user.Email,
        Name:          user.Name,
        DisplayName:   user.DisplayName,
        Bio:           user.Bio,
        Timezone:      user.Timezone,
        Language:      user.Language,
        Status:        UserStatus(user.Status),
        EmailVerified: user.EmailVerified,
        CreatedAt:     user.CreatedAt,
        UpdatedAt:     user.UpdatedAt,
        LastActiveAt:  user.LastActiveAt,
        LoginCount:    user.LoginCount,
        CustomFields:  user.CustomFields,
    }

    // Get profile picture if exists
    if user.ProfilePictureID != nil {
        if picture, err := s.userRepo.GetProfilePicture(context.Background(), *user.ProfilePictureID); err == nil {
            profile.ProfilePicture = picture
        }
    }

    return profile
}

func (s *UserServiceImpl) buildProfileCacheKey(userID string) string {
    return fmt.Sprintf("user_profile:%s", userID)
}

func (s *UserServiceImpl) buildPreferencesCacheKey(userID string) string {
    return fmt.Sprintf("user_preferences:%s", userID)
}

func (s *UserServiceImpl) invalidateUserCaches(userID string) {
    patterns := []string{
        fmt.Sprintf("user_profile:%s", userID),
        fmt.Sprintf("user_preferences:%s", userID),
        fmt.Sprintf("user_stats:%s", userID),
        fmt.Sprintf("user_sessions:%s", userID),
    }

    for _, pattern := range patterns {
        s.cache.Delete(context.Background(), pattern)
    }
}

func (s *UserServiceImpl) isValidTimezone(tz string) bool {
    _, err := time.LoadLocation(tz)
    return err == nil
}

func (s *UserServiceImpl) isValidLanguage(lang string) bool {
    validLanguages := []string{"en", "es", "fr", "de", "it", "pt", "ru", "ja", "ko", "zh"}
    for _, valid := range validLanguages {
        if lang == valid {
            return true
        }
    }
    return false
}

func (s *UserServiceImpl) logGDPRAction(userID, action, details string) {
    s.logger.Info("GDPR action performed",
        "user_id", userID,
        "action", action,
        "details", details,
        "timestamp", time.Now().Format(time.RFC3339))
}
```

## Testing Strategy

### Unit Tests

- Profile and preferences CRUD operations
- Validation logic and business rules
- Cache integration and invalidation
- Data export and deletion workflows
- Error handling and edge cases

### Integration Tests

- End-to-end user management flows
- File upload and storage integration
- GDPR compliance workflows
- Event publishing and handling
- Performance under concurrent load

### Security Tests

- User data isolation verification
- Profile picture upload security
- Data export encryption validation
- Audit trail completeness

## Configuration

### Environment Variables

```env
# User Service Configuration
PROFILE_CACHE_TTL=30m
PREFERENCES_CACHE_TTL=1h
MAX_PROFILE_PICTURE_SIZE=5242880
ALLOWED_IMAGE_TYPES=jpg,jpeg,png,webp
DATA_EXPORT_TIMEOUT=30m
MAX_SEARCH_RESULTS=100
ACTIVITY_RETENTION_DAYS=90
ENABLE_DATA_EXPORT_ENCRYPTION=true

# File Storage
STORAGE_PROVIDER=s3
STORAGE_BUCKET=englog-profile-pictures
STORAGE_REGION=us-west-2
```

## Dependencies

### External Dependencies

- User repository and database models
- File storage service (S3, GCS, etc.)
- Cache service (Redis)
- Event publishing system
- Validation and sanitization framework

### Internal Dependencies

- JWT authentication system
- Session management
- Audit logging system
- Metrics collection

## Deliverables

1. **User Service:** Complete user management implementation
2. **Profile Management:** CRUD operations with caching
3. **Preferences System:** Comprehensive user settings
4. **File Upload:** Profile picture management
5. **GDPR Compliance:** Data export and deletion
6. **Test Suite:** Unit and integration tests
7. **Documentation:** API documentation and usage examples

## Definition of Done

- [ ] All user profile operations implemented with validation
- [ ] Preferences system with comprehensive settings management
- [ ] Profile picture upload with security validation
- [ ] User search and analytics with pagination
- [ ] Data export functionality with encryption option
- [ ] GDPR compliant data deletion workflows
- [ ] Cache integration reduces database queries by 70%+
- [ ] File operations handle 5MB+ uploads efficiently
- [ ] User operations complete under 100ms for 95% of requests
- [ ] Comprehensive audit logging for all user actions
- [ ] Unit tests achieve 95%+ coverage
- [ ] Integration tests validate end-to-end workflows
- [ ] Security tests verify data isolation
- [ ] Event publishing enables real-time updates
- [ ] Performance tests meet latency requirements

---

**Estimated Timeline:** 3 days
**Risk Level:** Medium (file handling and GDPR compliance complexity)
**Blockers:** MVP-003 (JWT Authentication)
**Follow-up Tasks:** MVP-008 (Authenticated API), MVP-013 (Frontend User Management)
