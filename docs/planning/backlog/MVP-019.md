# MVP-019: Testing Framework & Unit Tests

**Feature Area:** MVP-TESTING (Testing Infrastructure)
**Priority:** P1 (High)
**Effort:** Medium (3 days)
**Dependencies:** MVP-001 (PostgreSQL Database), MVP-002 (Redis Infrastructure)

## Overview

Establish a comprehensive testing framework with unit tests, mocks, and test utilities to ensure code quality and enable confident refactoring. This includes setting up test databases, implementing table-driven tests, and creating comprehensive test coverage for all business logic components.

## Business Context

A robust testing framework is essential for maintaining code quality, preventing regressions, and enabling rapid development iterations. Comprehensive unit tests provide the foundation for confident code changes and serve as living documentation of system behavior.

## Requirements

### Functional Requirements

1. **Testing Framework Setup**

   - Go testing framework with testify
   - Mockery for interface mocking
   - Test database setup and teardown
   - Parallel test execution support

2. **Unit Test Coverage**

   - Business logic layer tests (â‰¥90% coverage)
   - Service layer tests with mocks
   - Repository layer tests with test database
   - Utility function tests

3. **Test Utilities**

   - Test data factories and fixtures
   - Database cleanup utilities
   - Mock setup helpers
   - Test assertion helpers

4. **Test Organization**
   - Structured test packages
   - Table-driven test patterns
   - Test categorization (unit, integration)
   - Benchmark tests for performance

### Technical Requirements

1. **Test Infrastructure**

   - Isolated test database per test
   - Redis test instance management
   - Concurrent test execution
   - Test result reporting

2. **Mock Generation**

   - Automated mock generation
   - Interface-based mocking
   - Mock verification and assertion
   - Test doubles for external services

3. **Test Data Management**

   - Factory pattern for test data
   - Database seeding and cleanup
   - Fixture management
   - Test data isolation

4. **Coverage and Quality**
   - Code coverage measurement
   - Coverage reporting and visualization
   - Quality gates and thresholds
   - Performance regression detection

## Implementation

### 1. Testing Framework Setup

```go
// internal/testing/setup.go
package testing

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "os"
    "testing"
    "time"

    "github.com/google/uuid"
    "github.com/redis/go-redis/v9"
    "github.com/stretchr/testify/require"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/testcontainers/testcontainers-go/modules/redis"

    "englog/internal/config"
    "englog/internal/storage"
)

// TestSuite provides testing infrastructure
type TestSuite struct {
    DB          *sql.DB
    Redis       *redis.Client
    Config      *config.Config
    Cleanup     []func() error
    T           *testing.T
}

// NewTestSuite creates a new test suite with isolated resources
func NewTestSuite(t *testing.T) *TestSuite {
    suite := &TestSuite{
        T:       t,
        Cleanup: make([]func() error, 0),
    }

    // Set up test configuration
    suite.setupConfig()

    // Set up test database
    suite.setupDatabase()

    // Set up test Redis
    suite.setupRedis()

    // Register cleanup
    t.Cleanup(func() {
        suite.TearDown()
    })

    return suite
}

func (s *TestSuite) setupConfig() {
    s.Config = &config.Config{
        Environment: "test",
        Port:        0, // Random port for tests
        LogLevel:    "error", // Reduce noise in tests
        Database: config.DatabaseConfig{
            MaxConnections: 5,
            Timeout:       5 * time.Second,
        },
        Redis: config.RedisConfig{
            MaxRetries: 1,
            Timeout:    time.Second,
        },
    }
}

func (s *TestSuite) setupDatabase() {
    ctx := context.Background()

    // Start PostgreSQL container
    pgContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:15-alpine"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("testuser"),
        postgres.WithPassword("testpass"),
        testcontainers.WithWaitStrategy(
            wait.ForLog("database system is ready to accept connections").
                WithOccurrence(2).
                WithStartupTimeout(30*time.Second)),
    )
    require.NoError(s.T, err)

    // Get connection string
    connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
    require.NoError(s.T, err)

    // Connect to database
    db, err := sql.Open("postgres", connStr)
    require.NoError(s.T, err)

    // Verify connection
    require.NoError(s.T, db.Ping())

    s.DB = db
    s.Config.DatabaseURL = connStr

    // Register cleanup
    s.Cleanup = append(s.Cleanup, func() error {
        db.Close()
        return pgContainer.Terminate(ctx)
    })

    // Run migrations
    s.runMigrations()
}

func (s *TestSuite) setupRedis() {
    ctx := context.Background()

    // Start Redis container
    redisContainer, err := redis.RunContainer(ctx,
        testcontainers.WithImage("redis:7-alpine"),
        redis.WithSnapshotting(10, 1),
        redis.WithLogLevel(redis.LogLevelVerbose),
    )
    require.NoError(s.T, err)

    // Get connection string
    connStr, err := redisContainer.ConnectionString(ctx)
    require.NoError(s.T, err)

    // Create Redis client
    rdb := redis.NewClient(&redis.Options{
        Addr:     connStr,
        Password: "",
        DB:       0,
    })

    // Verify connection
    require.NoError(s.T, rdb.Ping(ctx).Err())

    s.Redis = rdb
    s.Config.RedisURL = connStr

    // Register cleanup
    s.Cleanup = append(s.Cleanup, func() error {
        rdb.Close()
        return redisContainer.Terminate(ctx)
    })
}

func (s *TestSuite) runMigrations() {
    migrations := []string{
        `CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`,

        `CREATE TABLE users (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            email VARCHAR(255) UNIQUE NOT NULL,
            name VARCHAR(255) NOT NULL,
            password_hash VARCHAR(255),
            auth_provider VARCHAR(50),
            auth_provider_id VARCHAR(255),
            preferences JSONB DEFAULT '{}',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,

        `CREATE TABLE journal_entries (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            raw_data JSONB NOT NULL,
            entry_type VARCHAR(50) DEFAULT 'text',
            processing_status VARCHAR(20) DEFAULT 'pending',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,

        `CREATE TABLE processed_content (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            journal_id UUID NOT NULL REFERENCES journal_entries(id) ON DELETE CASCADE,
            user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            task_type VARCHAR(100) NOT NULL,
            processed_data JSONB NOT NULL,
            confidence_score DECIMAL(3,2),
            ai_provider_info JSONB,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )`,

        `CREATE INDEX idx_journal_entries_user_id ON journal_entries(user_id)`,
        `CREATE INDEX idx_journal_entries_created_at ON journal_entries(created_at)`,
        `CREATE INDEX idx_processed_content_journal_id ON processed_content(journal_id)`,
        `CREATE INDEX idx_processed_content_task_type ON processed_content(task_type)`,
    }

    for _, migration := range migrations {
        _, err := s.DB.Exec(migration)
        require.NoError(s.T, err, "Failed to run migration: %s", migration)
    }
}

func (s *TestSuite) TearDown() {
    for _, cleanup := range s.Cleanup {
        if err := cleanup(); err != nil {
            log.Printf("Cleanup error: %v", err)
        }
    }
}

// ResetDatabase clears all data from test database
func (s *TestSuite) ResetDatabase() {
    tables := []string{
        "processed_content",
        "journal_entries",
        "users",
    }

    for _, table := range tables {
        _, err := s.DB.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
        require.NoError(s.T, err)
    }
}

// ResetRedis clears all data from test Redis
func (s *TestSuite) ResetRedis() {
    err := s.Redis.FlushAll(context.Background()).Err()
    require.NoError(s.T, err)
}
```

### 2. Test Data Factories

```go
// internal/testing/factories.go
package testing

import (
    "fmt"
    "time"
    "encoding/json"

    "github.com/google/uuid"
    "github.com/brianvoe/gofakeit/v6"

    "englog/internal/models"
)

// UserFactory creates test users
type UserFactory struct {
    suite *TestSuite
}

func NewUserFactory(suite *TestSuite) *UserFactory {
    return &UserFactory{suite: suite}
}

// UserOptions allows customizing user creation
type UserOptions struct {
    Email        *string
    Name         *string
    AuthProvider *string
    Preferences  map[string]interface{}
}

func (f *UserFactory) Create(opts ...func(*UserOptions)) *models.User {
    options := &UserOptions{}
    for _, opt := range opts {
        opt(options)
    }

    user := &models.User{
        ID:           uuid.New().String(),
        Email:        getOrDefault(options.Email, gofakeit.Email()),
        Name:         getOrDefault(options.Name, gofakeit.Name()),
        AuthProvider: getOrDefault(options.AuthProvider, "email"),
        Preferences:  getOrDefault(options.Preferences, map[string]interface{}{}),
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }

    // Insert into database
    prefsJSON, _ := json.Marshal(user.Preferences)
    _, err := f.suite.DB.Exec(`
        INSERT INTO users (id, email, name, auth_provider, preferences, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, user.ID, user.Email, user.Name, user.AuthProvider, prefsJSON, user.CreatedAt, user.UpdatedAt)

    require.NoError(f.suite.T, err)

    return user
}

func (f *UserFactory) CreateBatch(count int, opts ...func(*UserOptions)) []*models.User {
    users := make([]*models.User, count)
    for i := 0; i < count; i++ {
        users[i] = f.Create(opts...)
    }
    return users
}

// JournalFactory creates test journal entries
type JournalFactory struct {
    suite *TestSuite
}

func NewJournalFactory(suite *TestSuite) *JournalFactory {
    return &JournalFactory{suite: suite}
}

type JournalOptions struct {
    UserID           *string
    Content          *string
    EntryType        *string
    ProcessingStatus *string
    RawData          map[string]interface{}
}

func (f *JournalFactory) Create(opts ...func(*JournalOptions)) *models.JournalEntry {
    options := &JournalOptions{}
    for _, opt := range opts {
        opt(options)
    }

    // Create user if not provided
    userID := getOrDefault(options.UserID, "")
    if userID == "" {
        user := NewUserFactory(f.suite).Create()
        userID = user.ID
    }

    content := getOrDefault(options.Content, gofakeit.Sentence(20))
    rawData := options.RawData
    if rawData == nil {
        rawData = map[string]interface{}{
            "content": content,
            "mood":    gofakeit.Number(1, 10),
            "tags":    []string{gofakeit.Word(), gofakeit.Word()},
            "location": map[string]interface{}{
                "name": gofakeit.City(),
                "lat":  gofakeit.Latitude(),
                "lng":  gofakeit.Longitude(),
            },
        }
    }

    journal := &models.JournalEntry{
        ID:               uuid.New().String(),
        UserID:           userID,
        RawData:          rawData,
        EntryType:        getOrDefault(options.EntryType, "text"),
        ProcessingStatus: getOrDefault(options.ProcessingStatus, "pending"),
        CreatedAt:        time.Now(),
        UpdatedAt:        time.Now(),
    }

    // Insert into database
    rawDataJSON, _ := json.Marshal(journal.RawData)
    _, err := f.suite.DB.Exec(`
        INSERT INTO journal_entries (id, user_id, raw_data, entry_type, processing_status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, journal.ID, journal.UserID, rawDataJSON, journal.EntryType, journal.ProcessingStatus, journal.CreatedAt, journal.UpdatedAt)

    require.NoError(f.suite.T, err)

    return journal
}

func (f *JournalFactory) CreateBatch(count int, opts ...func(*JournalOptions)) []*models.JournalEntry {
    journals := make([]*models.JournalEntry, count)
    for i := 0; i < count; i++ {
        journals[i] = f.Create(opts...)
    }
    return journals
}

// ProcessedContentFactory creates test processed content
type ProcessedContentFactory struct {
    suite *TestSuite
}

func NewProcessedContentFactory(suite *TestSuite) *ProcessedContentFactory {
    return &ProcessedContentFactory{suite: suite}
}

type ProcessedContentOptions struct {
    JournalID        *string
    UserID           *string
    TaskType         *string
    ProcessedData    map[string]interface{}
    ConfidenceScore  *float64
}

func (f *ProcessedContentFactory) Create(opts ...func(*ProcessedContentOptions)) *models.ProcessedContent {
    options := &ProcessedContentOptions{}
    for _, opt := range opts {
        opt(options)
    }

    // Create journal if not provided
    journalID := getOrDefault(options.JournalID, "")
    userID := getOrDefault(options.UserID, "")
    if journalID == "" {
        journal := NewJournalFactory(f.suite).Create()
        journalID = journal.ID
        userID = journal.UserID
    }

    processedData := options.ProcessedData
    if processedData == nil {
        processedData = map[string]interface{}{
            "sentiment": map[string]interface{}{
                "score": gofakeit.Float64Range(0, 1),
                "label": gofakeit.RandomString([]string{"positive", "negative", "neutral"}),
            },
            "emotions": map[string]interface{}{
                "joy":     gofakeit.Float64Range(0, 1),
                "sadness": gofakeit.Float64Range(0, 1),
                "anger":   gofakeit.Float64Range(0, 1),
            },
            "themes": []string{gofakeit.Word(), gofakeit.Word()},
        }
    }

    content := &models.ProcessedContent{
        ID:              uuid.New().String(),
        JournalID:       journalID,
        UserID:          userID,
        TaskType:        getOrDefault(options.TaskType, "sentiment_analysis"),
        ProcessedData:   processedData,
        ConfidenceScore: getOrDefault(options.ConfidenceScore, gofakeit.Float64Range(0.7, 1.0)),
        CreatedAt:       time.Now(),
    }

    // Insert into database
    processedDataJSON, _ := json.Marshal(content.ProcessedData)
    _, err := f.suite.DB.Exec(`
        INSERT INTO processed_content (id, journal_id, user_id, task_type, processed_data, confidence_score, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, content.ID, content.JournalID, content.UserID, content.TaskType, processedDataJSON, content.ConfidenceScore, content.CreatedAt)

    require.NoError(f.suite.T, err)

    return content
}

// Helper function for optional parameters
func getOrDefault[T any](ptr *T, defaultValue T) T {
    if ptr != nil {
        return *ptr
    }
    return defaultValue
}

// Scenario builders for complex test data
type TestScenario struct {
    suite *TestSuite
}

func NewTestScenario(suite *TestSuite) *TestScenario {
    return &TestScenario{suite: suite}
}

// CreateUserWithJournals creates a user with specified number of journals
func (s *TestScenario) CreateUserWithJournals(journalCount int) (*models.User, []*models.JournalEntry) {
    user := NewUserFactory(s.suite).Create()

    journals := make([]*models.JournalEntry, journalCount)
    journalFactory := NewJournalFactory(s.suite)

    for i := 0; i < journalCount; i++ {
        journals[i] = journalFactory.Create(func(opts *JournalOptions) {
            opts.UserID = &user.ID
            content := fmt.Sprintf("Journal entry %d: %s", i+1, gofakeit.Sentence(10))
            opts.Content = &content
        })
    }

    return user, journals
}

// CreateProcessedJournal creates a journal with processed content
func (s *TestScenario) CreateProcessedJournal() (*models.User, *models.JournalEntry, *models.ProcessedContent) {
    user := NewUserFactory(s.suite).Create()

    journal := NewJournalFactory(s.suite).Create(func(opts *JournalOptions) {
        opts.UserID = &user.ID
        status := "completed"
        opts.ProcessingStatus = &status
    })

    processed := NewProcessedContentFactory(s.suite).Create(func(opts *ProcessedContentOptions) {
        opts.JournalID = &journal.ID
        opts.UserID = &user.ID
    })

    return user, journal, processed
}

// CreateMultipleUsersWithData creates multiple users each with journals
func (s *TestScenario) CreateMultipleUsersWithData(userCount, journalsPerUser int) []*models.User {
    users := make([]*models.User, userCount)

    for i := 0; i < userCount; i++ {
        user, _ := s.CreateUserWithJournals(journalsPerUser)
        users[i] = user
    }

    return users
}
```

### 3. Unit Test Examples

```go
// internal/services/journal_test.go
package services

import (
    "context"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"

    "englog/internal/models"
    "englog/internal/repositories/mocks"
    "englog/internal/testing"
)

// JournalServiceTestSuite provides test suite for journal service
type JournalServiceTestSuite struct {
    suite.Suite
    testSuite        *testing.TestSuite
    service          *JournalService
    mockRepo         *mocks.JournalRepository
    mockWorkerClient *mocks.WorkerClient
    mockPublisher    *mocks.EventPublisher
}

func (suite *JournalServiceTestSuite) SetupTest() {
    suite.testSuite = testing.NewTestSuite(suite.T())
    suite.mockRepo = mocks.NewJournalRepository(suite.T())
    suite.mockWorkerClient = mocks.NewWorkerClient(suite.T())
    suite.mockPublisher = mocks.NewEventPublisher(suite.T())

    suite.service = NewJournalService(
        suite.mockRepo,
        suite.mockWorkerClient,
        suite.mockPublisher,
    )
}

func (suite *JournalServiceTestSuite) TestCreateJournal() {
    ctx := context.Background()
    userID := "user-123"

    tests := []struct {
        name           string
        request        models.CreateJournalRequest
        setupMocks     func()
        expectedResult *models.JournalEntry
        expectedError  string
    }{
        {
            name: "successful creation with valid data",
            request: models.CreateJournalRequest{
                RawData: map[string]interface{}{
                    "content": "Today was a great day!",
                    "mood":    8,
                    "tags":    []string{"positive", "daily"},
                },
                EntryType: "text",
            },
            setupMocks: func() {
                // Mock repository save
                suite.mockRepo.On("Create", mock.Anything, mock.MatchedBy(func(journal *models.JournalEntry) bool {
                    return journal.UserID == userID &&
                           journal.RawData["content"] == "Today was a great day!" &&
                           journal.EntryType == "text"
                })).Return(nil).Once()

                // Mock worker submission
                suite.mockWorkerClient.On("SubmitTask", mock.Anything, mock.MatchedBy(func(task *models.ProcessingTask) bool {
                    return task.Type == "content_analysis" && task.JournalID != ""
                })).Return(nil).Once()

                // Mock event publishing
                suite.mockPublisher.On("Publish", mock.Anything, mock.MatchedBy(func(event *models.Event) bool {
                    return event.Type == "journal_created"
                })).Return(nil).Once()
            },
            expectedResult: &models.JournalEntry{
                UserID:           userID,
                EntryType:        "text",
                ProcessingStatus: "pending",
            },
        },
        {
            name: "validation error with empty content",
            request: models.CreateJournalRequest{
                RawData: map[string]interface{}{},
            },
            setupMocks: func() {
                // No mocks should be called
            },
            expectedError: "validation failed: raw_data cannot be empty",
        },
        {
            name: "repository error during save",
            request: models.CreateJournalRequest{
                RawData: map[string]interface{}{
                    "content": "Valid content",
                },
            },
            setupMocks: func() {
                suite.mockRepo.On("Create", mock.Anything, mock.Anything).
                    Return(fmt.Errorf("database connection failed")).Once()
            },
            expectedError: "failed to create journal: database connection failed",
        },
        {
            name: "worker submission failure with retry",
            request: models.CreateJournalRequest{
                RawData: map[string]interface{}{
                    "content": "Content that fails worker submission",
                },
            },
            setupMocks: func() {
                suite.mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil).Once()

                // First submission fails, second succeeds
                suite.mockWorkerClient.On("SubmitTask", mock.Anything, mock.Anything).
                    Return(fmt.Errorf("worker unavailable")).Once()
                suite.mockWorkerClient.On("SubmitTask", mock.Anything, mock.Anything).
                    Return(nil).Once()

                suite.mockPublisher.On("Publish", mock.Anything, mock.Anything).Return(nil).Once()
            },
            expectedResult: &models.JournalEntry{
                UserID:           userID,
                ProcessingStatus: "pending",
            },
        },
    }

    for _, tt := range tests {
        suite.Run(tt.name, func() {
            // Setup
            tt.setupMocks()

            // Execute
            result, err := suite.service.CreateJournal(ctx, userID, tt.request)

            // Assert
            if tt.expectedError != "" {
                assert.Error(suite.T(), err)
                assert.Contains(suite.T(), err.Error(), tt.expectedError)
                assert.Nil(suite.T(), result)
            } else {
                assert.NoError(suite.T(), err)
                assert.NotNil(suite.T(), result)
                assert.Equal(suite.T(), tt.expectedResult.UserID, result.UserID)
                assert.Equal(suite.T(), tt.expectedResult.EntryType, result.EntryType)
                assert.Equal(suite.T(), tt.expectedResult.ProcessingStatus, result.ProcessingStatus)
                assert.NotEmpty(suite.T(), result.ID)
                assert.WithinDuration(suite.T(), time.Now(), result.CreatedAt, time.Second)
            }

            // Verify all mocks
            suite.mockRepo.AssertExpectations(suite.T())
            suite.mockWorkerClient.AssertExpectations(suite.T())
            suite.mockPublisher.AssertExpectations(suite.T())
        })
    }
}

func (suite *JournalServiceTestSuite) TestGetUserJournals() {
    ctx := context.Background()
    userID := "user-123"

    // Create test data
    expectedJournals := []*models.JournalEntry{
        {
            ID:     "journal-1",
            UserID: userID,
            RawData: map[string]interface{}{
                "content": "First journal",
            },
            CreatedAt: time.Now().Add(-2 * time.Hour),
        },
        {
            ID:     "journal-2",
            UserID: userID,
            RawData: map[string]interface{}{
                "content": "Second journal",
            },
            CreatedAt: time.Now().Add(-1 * time.Hour),
        },
    }

    tests := []struct {
        name           string
        limit          int
        offset         int
        setupMocks     func()
        expectedResult []*models.JournalEntry
        expectedError  string
    }{
        {
            name:   "successful retrieval with default pagination",
            limit:  20,
            offset: 0,
            setupMocks: func() {
                suite.mockRepo.On("GetByUserID", ctx, userID, 20, 0).
                    Return(expectedJournals, nil).Once()
            },
            expectedResult: expectedJournals,
        },
        {
            name:   "successful retrieval with custom pagination",
            limit:  10,
            offset: 5,
            setupMocks: func() {
                suite.mockRepo.On("GetByUserID", ctx, userID, 10, 5).
                    Return([]*models.JournalEntry{expectedJournals[1]}, nil).Once()
            },
            expectedResult: []*models.JournalEntry{expectedJournals[1]},
        },
        {
            name:   "repository error",
            limit:  20,
            offset: 0,
            setupMocks: func() {
                suite.mockRepo.On("GetByUserID", ctx, userID, 20, 0).
                    Return(nil, fmt.Errorf("database error")).Once()
            },
            expectedError: "failed to get user journals: database error",
        },
        {
            name:   "empty result set",
            limit:  20,
            offset: 0,
            setupMocks: func() {
                suite.mockRepo.On("GetByUserID", ctx, userID, 20, 0).
                    Return([]*models.JournalEntry{}, nil).Once()
            },
            expectedResult: []*models.JournalEntry{},
        },
    }

    for _, tt := range tests {
        suite.Run(tt.name, func() {
            // Setup
            tt.setupMocks()

            // Execute
            result, err := suite.service.GetUserJournals(ctx, userID, tt.limit, tt.offset)

            // Assert
            if tt.expectedError != "" {
                assert.Error(suite.T(), err)
                assert.Contains(suite.T(), err.Error(), tt.expectedError)
                assert.Nil(suite.T(), result)
            } else {
                assert.NoError(suite.T(), err)
                assert.Equal(suite.T(), len(tt.expectedResult), len(result))
                for i, expected := range tt.expectedResult {
                    assert.Equal(suite.T(), expected.ID, result[i].ID)
                    assert.Equal(suite.T(), expected.UserID, result[i].UserID)
                }
            }

            // Verify mocks
            suite.mockRepo.AssertExpectations(suite.T())
        })
    }
}

func (suite *JournalServiceTestSuite) TestConcurrentJournalCreation() {
    ctx := context.Background()
    userID := "user-123"

    // Setup mocks for concurrent operations
    suite.mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil).Times(10)
    suite.mockWorkerClient.On("SubmitTask", mock.Anything, mock.Anything).Return(nil).Times(10)
    suite.mockPublisher.On("Publish", mock.Anything, mock.Anything).Return(nil).Times(10)

    // Create channels for synchronization
    results := make(chan *models.JournalEntry, 10)
    errors := make(chan error, 10)

    // Launch concurrent journal creations
    for i := 0; i < 10; i++ {
        go func(index int) {
            request := models.CreateJournalRequest{
                RawData: map[string]interface{}{
                    "content": fmt.Sprintf("Concurrent journal %d", index),
                },
            }

            result, err := suite.service.CreateJournal(ctx, userID, request)
            if err != nil {
                errors <- err
            } else {
                results <- result
            }
        }(i)
    }

    // Collect results
    var successfulCreations []*models.JournalEntry
    var creationErrors []error

    for i := 0; i < 10; i++ {
        select {
        case result := <-results:
            successfulCreations = append(successfulCreations, result)
        case err := <-errors:
            creationErrors = append(creationErrors, err)
        case <-time.After(5 * time.Second):
            suite.T().Fatal("Timeout waiting for concurrent operations")
        }
    }

    // Assert all operations completed successfully
    assert.Len(suite.T(), successfulCreations, 10)
    assert.Len(suite.T(), creationErrors, 0)

    // Verify all journals have unique IDs
    uniqueIDs := make(map[string]bool)
    for _, journal := range successfulCreations {
        assert.False(suite.T(), uniqueIDs[journal.ID], "Duplicate journal ID: %s", journal.ID)
        uniqueIDs[journal.ID] = true
    }
}

func TestJournalServiceTestSuite(t *testing.T) {
    suite.Run(t, new(JournalServiceTestSuite))
}
```

### 4. Repository Tests with Real Database

```go
// internal/repositories/journal_test.go
package repositories

import (
    "context"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"

    "englog/internal/models"
    "englog/internal/testing"
)

type JournalRepositoryTestSuite struct {
    suite.Suite
    testSuite *testing.TestSuite
    repo      *JournalRepository
}

func (suite *JournalRepositoryTestSuite) SetupTest() {
    suite.testSuite = testing.NewTestSuite(suite.T())
    suite.repo = NewJournalRepository(suite.testSuite.DB)

    // Reset database for each test
    suite.testSuite.ResetDatabase()
}

func (suite *JournalRepositoryTestSuite) TestCreate() {
    ctx := context.Background()

    // Create a test user first
    userFactory := testing.NewUserFactory(suite.testSuite)
    user := userFactory.Create()

    tests := []struct {
        name          string
        journal       *models.JournalEntry
        expectedError string
    }{
        {
            name: "successful creation",
            journal: &models.JournalEntry{
                ID:     "journal-123",
                UserID: user.ID,
                RawData: map[string]interface{}{
                    "content": "Test journal content",
                    "mood":    7,
                },
                EntryType:        "text",
                ProcessingStatus: "pending",
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
            },
        },
        {
            name: "duplicate ID error",
            journal: &models.JournalEntry{
                ID:     "journal-123", // Same ID as above
                UserID: user.ID,
                RawData: map[string]interface{}{
                    "content": "Different content",
                },
                EntryType: "text",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
            },
            expectedError: "duplicate key value",
        },
        {
            name: "foreign key constraint error",
            journal: &models.JournalEntry{
                ID:     "journal-456",
                UserID: "non-existent-user",
                RawData: map[string]interface{}{
                    "content": "Test content",
                },
                EntryType: "text",
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
            },
            expectedError: "foreign key constraint",
        },
    }

    for _, tt := range tests {
        suite.Run(tt.name, func() {
            err := suite.repo.Create(ctx, tt.journal)

            if tt.expectedError != "" {
                assert.Error(suite.T(), err)
                assert.Contains(suite.T(), err.Error(), tt.expectedError)
            } else {
                assert.NoError(suite.T(), err)

                // Verify the journal was created
                created, err := suite.repo.GetByID(ctx, tt.journal.ID)
                require.NoError(suite.T(), err)
                assert.Equal(suite.T(), tt.journal.ID, created.ID)
                assert.Equal(suite.T(), tt.journal.UserID, created.UserID)
                assert.Equal(suite.T(), tt.journal.RawData["content"], created.RawData["content"])
            }
        })
    }
}

func (suite *JournalRepositoryTestSuite) TestGetByUserID() {
    ctx := context.Background()

    // Create test scenario with user and journals
    scenario := testing.NewTestScenario(suite.testSuite)
    user, journals := scenario.CreateUserWithJournals(5)

    tests := []struct {
        name           string
        userID         string
        limit          int
        offset         int
        expectedCount  int
        expectedFirst  string
    }{
        {
            name:          "get all journals",
            userID:        user.ID,
            limit:         10,
            offset:        0,
            expectedCount: 5,
            expectedFirst: journals[0].ID,
        },
        {
            name:          "paginated results",
            userID:        user.ID,
            limit:         2,
            offset:        1,
            expectedCount: 2,
            expectedFirst: journals[1].ID,
        },
        {
            name:          "no journals for non-existent user",
            userID:        "non-existent",
            limit:         10,
            offset:        0,
            expectedCount: 0,
        },
    }

    for _, tt := range tests {
        suite.Run(tt.name, func() {
            result, err := suite.repo.GetByUserID(ctx, tt.userID, tt.limit, tt.offset)

            assert.NoError(suite.T(), err)
            assert.Len(suite.T(), result, tt.expectedCount)

            if tt.expectedCount > 0 {
                // Results should be ordered by created_at DESC
                assert.Equal(suite.T(), tt.expectedFirst, result[0].ID)

                // Verify ordering
                for i := 1; i < len(result); i++ {
                    assert.True(suite.T(), result[i-1].CreatedAt.After(result[i].CreatedAt) ||
                                          result[i-1].CreatedAt.Equal(result[i].CreatedAt))
                }
            }
        })
    }
}

func (suite *JournalRepositoryTestSuite) TestSearch() {
    ctx := context.Background()

    // Create user and journals with specific content
    userFactory := testing.NewUserFactory(suite.testSuite)
    user := userFactory.Create()

    journalFactory := testing.NewJournalFactory(suite.testSuite)

    // Create journals with searchable content
    journals := []*models.JournalEntry{
        journalFactory.Create(func(opts *testing.JournalOptions) {
            opts.UserID = &user.ID
            content := "Today was a productive day at work"
            opts.Content = &content
        }),
        journalFactory.Create(func(opts *testing.JournalOptions) {
            opts.UserID = &user.ID
            content := "Had a great meeting with the team"
            opts.Content = &content
        }),
        journalFactory.Create(func(opts *testing.JournalOptions) {
            opts.UserID = &user.ID
            content := "Feeling anxious about the presentation"
            opts.Content = &content
        }),
    }

    tests := []struct {
        name          string
        userID        string
        searchTerm    string
        expectedCount int
        expectedIDs   []string
    }{
        {
            name:          "search for 'work'",
            userID:        user.ID,
            searchTerm:    "work",
            expectedCount: 1,
            expectedIDs:   []string{journals[0].ID},
        },
        {
            name:          "search for 'team'",
            userID:        user.ID,
            searchTerm:    "team",
            expectedCount: 1,
            expectedIDs:   []string{journals[1].ID},
        },
        {
            name:          "search for common word",
            userID:        user.ID,
            searchTerm:    "day",
            expectedCount: 1,
            expectedIDs:   []string{journals[0].ID},
        },
        {
            name:          "search with no results",
            userID:        user.ID,
            searchTerm:    "vacation",
            expectedCount: 0,
            expectedIDs:   []string{},
        },
    }

    for _, tt := range tests {
        suite.Run(tt.name, func() {
            result, err := suite.repo.Search(ctx, tt.userID, tt.searchTerm, 10, 0)

            assert.NoError(suite.T(), err)
            assert.Len(suite.T(), result, tt.expectedCount)

            if tt.expectedCount > 0 {
                actualIDs := make([]string, len(result))
                for i, journal := range result {
                    actualIDs[i] = journal.ID
                }
                assert.ElementsMatch(suite.T(), tt.expectedIDs, actualIDs)
            }
        })
    }
}

func (suite *JournalRepositoryTestSuite) TestTransactionRollback() {
    ctx := context.Background()

    userFactory := testing.NewUserFactory(suite.testSuite)
    user := userFactory.Create()

    // Start a transaction
    tx, err := suite.testSuite.DB.Begin()
    require.NoError(suite.T(), err)

    repoWithTx := NewJournalRepositoryWithTx(tx)

    // Create a journal within transaction
    journal := &models.JournalEntry{
        ID:     "tx-journal",
        UserID: user.ID,
        RawData: map[string]interface{}{
            "content": "Transaction test",
        },
        EntryType: "text",
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }

    err = repoWithTx.Create(ctx, journal)
    require.NoError(suite.T(), err)

    // Rollback transaction
    err = tx.Rollback()
    require.NoError(suite.T(), err)

    // Verify journal doesn't exist after rollback
    _, err = suite.repo.GetByID(ctx, journal.ID)
    assert.Error(suite.T(), err)
    assert.Contains(suite.T(), err.Error(), "not found")
}

func TestJournalRepositoryTestSuite(t *testing.T) {
    suite.Run(t, new(JournalRepositoryTestSuite))
}
```

### 5. Benchmark Tests

```go
// internal/repositories/journal_bench_test.go
package repositories

import (
    "context"
    "testing"

    "englog/internal/testing"
)

func BenchmarkJournalRepository_Create(b *testing.B) {
    suite := testing.NewTestSuite(&testing.T{})
    defer suite.TearDown()

    repo := NewJournalRepository(suite.DB)
    userFactory := testing.NewUserFactory(suite)
    journalFactory := testing.NewJournalFactory(suite)

    // Create test user
    user := userFactory.Create()

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        journal := journalFactory.Create(func(opts *testing.JournalOptions) {
            opts.UserID = &user.ID
        })

        err := repo.Create(context.Background(), journal)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkJournalRepository_GetByUserID(b *testing.B) {
    suite := testing.NewTestSuite(&testing.T{})
    defer suite.TearDown()

    repo := NewJournalRepository(suite.DB)
    scenario := testing.NewTestScenario(suite)

    // Pre-populate with test data
    user, _ := scenario.CreateUserWithJournals(1000)

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        _, err := repo.GetByUserID(context.Background(), user.ID, 20, 0)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkJournalRepository_Search(b *testing.B) {
    suite := testing.NewTestSuite(&testing.T{})
    defer suite.TearDown()

    repo := NewJournalRepository(suite.DB)
    scenario := testing.NewTestScenario(suite)

    // Pre-populate with searchable data
    user, _ := scenario.CreateUserWithJournals(100)

    searchTerms := []string{"work", "happy", "meeting", "productive", "day"}

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        term := searchTerms[i%len(searchTerms)]
        _, err := repo.Search(context.Background(), user.ID, term, 10, 0)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

### 6. Test Utilities and Helpers

```go
// internal/testing/assertions.go
package testing

import (
    "encoding/json"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "englog/internal/models"
)

// AssertJournalEqual compares two journal entries for equality
func AssertJournalEqual(t *testing.T, expected, actual *models.JournalEntry) {
    assert.Equal(t, expected.ID, actual.ID)
    assert.Equal(t, expected.UserID, actual.UserID)
    assert.Equal(t, expected.EntryType, actual.EntryType)
    assert.Equal(t, expected.ProcessingStatus, actual.ProcessingStatus)

    // Compare JSON data
    expectedJSON, _ := json.Marshal(expected.RawData)
    actualJSON, _ := json.Marshal(actual.RawData)
    assert.JSONEq(t, string(expectedJSON), string(actualJSON))

    // Compare timestamps with tolerance
    assert.WithinDuration(t, expected.CreatedAt, actual.CreatedAt, time.Second)
    assert.WithinDuration(t, expected.UpdatedAt, actual.UpdatedAt, time.Second)
}

// AssertValidJournal validates journal structure
func AssertValidJournal(t *testing.T, journal *models.JournalEntry) {
    assert.NotEmpty(t, journal.ID)
    assert.NotEmpty(t, journal.UserID)
    assert.NotNil(t, journal.RawData)
    assert.NotEmpty(t, journal.EntryType)
    assert.NotZero(t, journal.CreatedAt)
    assert.NotZero(t, journal.UpdatedAt)

    // Validate UUID format
    assert.Regexp(t, `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, journal.ID)
    assert.Regexp(t, `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`, journal.UserID)
}

// AssertResponseHeaders validates HTTP response headers
func AssertResponseHeaders(t *testing.T, headers map[string][]string) {
    assert.Contains(t, headers, "Content-Type")
    assert.Contains(t, headers["Content-Type"][0], "application/json")

    // Security headers
    assert.Contains(t, headers, "X-Content-Type-Options")
    assert.Equal(t, "nosniff", headers["X-Content-Type-Options"][0])
}

// AssertEventPublished verifies event was published with correct data
func AssertEventPublished(t *testing.T, mockPublisher *mocks.EventPublisher, eventType string) {
    calls := mockPublisher.Calls
    found := false

    for _, call := range calls {
        if call.Method == "Publish" && len(call.Arguments) >= 2 {
            if event, ok := call.Arguments[1].(*models.Event); ok {
                if event.Type == eventType {
                    found = true
                    break
                }
            }
        }
    }

    assert.True(t, found, "Expected event type %s was not published", eventType)
}

// RequireNoError fails test immediately on error with context
func RequireNoError(t *testing.T, err error, context string) {
    require.NoError(t, err, "Unexpected error in %s: %v", context, err)
}

// AssertJSONContains checks if JSON contains specific fields
func AssertJSONContains(t *testing.T, jsonStr string, expectedFields map[string]interface{}) {
    var data map[string]interface{}
    err := json.Unmarshal([]byte(jsonStr), &data)
    require.NoError(t, err, "Failed to parse JSON: %s", jsonStr)

    for field, expectedValue := range expectedFields {
        assert.Contains(t, data, field, "JSON missing field: %s", field)
        if expectedValue != nil {
            assert.Equal(t, expectedValue, data[field], "JSON field %s has wrong value", field)
        }
    }
}

// TimePointer creates a pointer to time.Time for optional fields
func TimePointer(t time.Time) *time.Time {
    return &t
}

// StringPointer creates a pointer to string for optional fields
func StringPointer(s string) *string {
    return &s
}

// IntPointer creates a pointer to int for optional fields
func IntPointer(i int) *int {
    return &i
}
```

## Testing Configuration

### Test Environment Setup

```bash
#!/bin/bash
# scripts/setup-test-env.sh

set -e

echo "ðŸ”§ Setting up test environment..."

# Install test dependencies
go install github.com/vektra/mockery/v2@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Generate mocks
echo "ðŸ¤– Generating mocks..."
mockery --dir=internal/repositories --all --output=internal/repositories/mocks
mockery --dir=internal/services --all --output=internal/services/mocks
mockery --dir=internal/ai --all --output=internal/ai/mocks
mockery --dir=internal/worker --all --output=internal/worker/mocks

# Run tests with coverage
echo "ðŸ§ª Running tests with coverage..."
go test -v -race -coverprofile=coverage.out ./...

# Generate coverage report
echo "ðŸ“Š Generating coverage report..."
go tool cover -html=coverage.out -o coverage.html

# Run benchmarks
echo "âš¡ Running benchmarks..."
go test -bench=. -benchmem ./... > bench.out

echo "âœ… Test environment setup complete!"
echo "ðŸ“‚ Files generated:"
echo "  - coverage.out (coverage data)"
echo "  - coverage.html (coverage report)"
echo "  - bench.out (benchmark results)"
```

### Makefile Test Targets

```makefile
# Makefile test targets

.PHONY: test test-unit test-integration test-coverage test-race test-bench

# Run all tests
test: test-unit test-integration

# Run unit tests only
test-unit:
	@echo "Running unit tests..."
	go test -short -v ./...

# Run integration tests (requires containers)
test-integration:
	@echo "Running integration tests..."
	go test -tags=integration -v ./...

# Run tests with coverage
test-coverage:
	@echo "Running tests with coverage..."
	go test -v -race -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# Run tests with race detection
test-race:
	@echo "Running tests with race detection..."
	go test -race -v ./...

# Run benchmark tests
test-bench:
	@echo "Running benchmark tests..."
	go test -bench=. -benchmem ./... | tee bench.out

# Generate test mocks
test-mocks:
	@echo "Generating test mocks..."
	mockery --dir=internal/repositories --all --output=internal/repositories/mocks
	mockery --dir=internal/services --all --output=internal/services/mocks

# Clean test artifacts
test-clean:
	@echo "Cleaning test artifacts..."
	rm -f coverage.out coverage.html bench.out
	rm -rf internal/*/mocks

# Test with verbose output and specific package
test-verbose:
	go test -v -count=1 ./internal/services/...

# Quick smoke test
test-smoke:
	@echo "Running smoke tests..."
	go test -short -timeout=30s ./...
```

## Acceptance Criteria

### Framework Setup

- [ ] Test framework configured with testify and testcontainers
- [ ] Isolated test databases created for each test
- [ ] Mock generation automated with mockery
- [ ] Test utilities and helpers implemented
- [ ] Test data factories and fixtures created

### Test Coverage

- [ ] Unit tests achieve â‰¥90% coverage for business logic
- [ ] All service layer methods have comprehensive tests
- [ ] Repository layer tested with real database
- [ ] Table-driven tests implemented for complex scenarios
- [ ] Concurrent operation tests included

### Test Quality

- [ ] Tests follow AAA pattern (Arrange, Act, Assert)
- [ ] Test names clearly describe scenarios
- [ ] Mock expectations properly verified
- [ ] Error cases and edge cases covered
- [ ] Performance regression tests implemented

### Integration

- [ ] CI/CD pipeline runs all tests
- [ ] Coverage reports generated automatically
- [ ] Test results visible in PR reviews
- [ ] Benchmark results tracked over time
- [ ] Quality gates prevent coverage regression

### Documentation

- [ ] Testing guidelines documented
- [ ] Test data factory usage examples
- [ ] Mock setup patterns documented
- [ ] Benchmark interpretation guide
- [ ] Debugging test failures guide

## Success Metrics

- Test coverage â‰¥90% for critical business logic
- All tests pass consistently in CI/CD pipeline
- Test execution time < 5 minutes for full suite
- Zero flaky tests in CI environment
- 100% of new code includes corresponding tests
