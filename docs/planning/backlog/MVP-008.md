# MVP-008: Authenticated Journal CRUD API

**Feature:** MVP-API
**Priority:** P0 (Critical)
**Effort:** Large (4 days)
**Dependencies:** MVP-003 (JWT Authentication), MVP-007 (Journal Data Models)

## Objective

Implement complete authenticated REST API for journal management with user-specific data access, replacing the open prototype API with production-ready secured endpoints.

## Technical Scope

### API Endpoints Implementation

- User-authenticated journal CRUD operations
- Input validation and sanitization
- Error handling and status codes
- Rate limiting and request throttling
- API documentation and OpenAPI specification

### User Data Isolation

- Row-level security for user data
- User context from JWT authentication
- Data access authorization
- Cross-user data protection

### Data Validation

- JSON schema validation for journal entries
- Content size limits and restrictions
- Metadata validation and sanitization
- Error messages and field validation

## Acceptance Criteria

### Functional Requirements

- [ ] All journal operations require valid JWT authentication
- [ ] Users can only access their own journal data
- [ ] Complete CRUD operations for journal entries
- [ ] Input validation with clear error messages
- [ ] Pagination support for journal listings

### API Requirements

- [ ] RESTful API design principles followed
- [ ] Consistent JSON response format
- [ ] Proper HTTP status codes returned
- [ ] Request/response logging implemented
- [ ] API rate limiting configured

### Security Requirements

- [ ] User data isolation enforced
- [ ] Input sanitization preventing XSS/injection
- [ ] Request size limits enforced
- [ ] Audit logging for data modifications
- [ ] CORS configuration for web clients

## Implementation Details

### API Endpoint Specification

```
GET    /api/journals              # List user's journals (paginated)
POST   /api/journals              # Create new journal entry
GET    /api/journals/{id}         # Get specific journal entry
PUT    /api/journals/{id}         # Update journal entry
DELETE /api/journals/{id}         # Delete journal entry
GET    /api/journals/{id}/processed # Get processed content for entry
```

### Request/Response Models

```go
// Create Journal Request
type CreateJournalRequest struct {
    RawData   map[string]any `json:"raw_data" validate:"required"`
    EntryType string         `json:"entry_type" validate:"omitempty,oneof=text voice photo mixed"`
    Metadata  map[string]any `json:"metadata" validate:"omitempty"`
}

// Journal Response
type JournalResponse struct {
    ID               string                 `json:"id"`
    UserID           string                 `json:"user_id"`
    RawData          map[string]any         `json:"raw_data"`
    EntryType        string                 `json:"entry_type"`
    Metadata         map[string]any         `json:"metadata"`
    ProcessingStatus string                 `json:"processing_status"`
    CreatedAt        time.Time              `json:"created_at"`
    UpdatedAt        time.Time              `json:"updated_at"`
}

// List Journals Response
type ListJournalsResponse struct {
    Journals   []JournalResponse `json:"journals"`
    TotalCount int               `json:"total_count"`
    Page       int               `json:"page"`
    PageSize   int               `json:"page_size"`
    HasMore    bool              `json:"has_more"`
}
```

### Handler Implementation

```go
type JournalHandler struct {
    service    JournalService
    validator  *validator.Validate
    logger     *slog.Logger
}

func (h *JournalHandler) CreateJournal(c *gin.Context) {
    userID := c.GetString("user_id")
    if userID == "" {
        c.JSON(401, gin.H{"error": "Authentication required"})
        return
    }

    var req CreateJournalRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request format", "details": err.Error()})
        return
    }

    if err := h.validator.Struct(req); err != nil {
        c.JSON(400, gin.H{"error": "Validation failed", "details": formatValidationErrors(err)})
        return
    }

    journal, err := h.service.CreateJournal(c.Request.Context(), userID, req)
    if err != nil {
        h.logger.Error("Failed to create journal", "error", err, "user_id", userID)
        c.JSON(500, gin.H{"error": "Failed to create journal"})
        return
    }

    c.JSON(201, journal)
}

func (h *JournalHandler) GetJournals(c *gin.Context) {
    userID := c.GetString("user_id")
    page := getIntQuery(c, "page", 1)
    pageSize := getIntQuery(c, "page_size", 20)

    if pageSize > 100 {
        pageSize = 100 // Maximum page size
    }

    journals, totalCount, err := h.service.GetUserJournals(c.Request.Context(), userID, page, pageSize)
    if err != nil {
        h.logger.Error("Failed to get journals", "error", err, "user_id", userID)
        c.JSON(500, gin.H{"error": "Failed to retrieve journals"})
        return
    }

    response := ListJournalsResponse{
        Journals:   journals,
        TotalCount: totalCount,
        Page:       page,
        PageSize:   pageSize,
        HasMore:    (page * pageSize) < totalCount,
    }

    c.JSON(200, response)
}
```

### Input Validation

```go
type ValidationRules struct {
    MaxContentSize   int64  // 50KB for journal content
    MaxMetadataSize  int64  // 10KB for metadata
    AllowedEntryTypes []string
    RequiredFields   []string
}

func (h *JournalHandler) validateJournalContent(rawData map[string]any) error {
    // Check content size
    jsonData, _ := json.Marshal(rawData)
    if len(jsonData) > h.rules.MaxContentSize {
        return fmt.Errorf("content exceeds maximum size of %d bytes", h.rules.MaxContentSize)
    }

    // Validate content structure
    if content, exists := rawData["content"]; exists {
        if str, ok := content.(string); ok {
            if len(strings.TrimSpace(str)) == 0 {
                return fmt.Errorf("content cannot be empty")
            }
        }
    }

    // Sanitize string fields to prevent XSS
    h.sanitizeMapValues(rawData)

    return nil
}

func (h *JournalHandler) sanitizeMapValues(data map[string]any) {
    for key, value := range data {
        if str, ok := value.(string); ok {
            data[key] = html.EscapeString(str)
        } else if nestedMap, ok := value.(map[string]any); ok {
            h.sanitizeMapValues(nestedMap)
        }
    }
}
```

### Rate Limiting Configuration

```go
type RateLimitConfig struct {
    CreateJournal  int // 20 requests per minute
    GetJournals    int // 60 requests per minute
    UpdateJournal  int // 10 requests per minute
    DeleteJournal  int // 5 requests per minute
}

func ApplyRateLimiting(r *gin.Engine, config RateLimitConfig) {
    store := memory.NewStore()

    r.POST("/api/journals",
        gin_limiter.NewRateLimiter(store, config.CreateJournal, time.Minute),
        journalHandler.CreateJournal)

    r.GET("/api/journals",
        gin_limiter.NewRateLimiter(store, config.GetJournals, time.Minute),
        journalHandler.GetJournals)
}
```

## Testing Strategy

### Unit Tests

- Handler function validation
- Input sanitization and validation
- User context extraction
- Error handling scenarios
- Response formatting

### Integration Tests

- End-to-end API workflow
- Database integration testing
- Authentication middleware integration
- Rate limiting behavior
- Multi-user data isolation

### API Tests

- All CRUD operations with valid/invalid data
- Authentication edge cases
- Pagination functionality
- Content size limits
- Cross-user access prevention

## Error Handling

### Standard Error Responses

```go
type APIError struct {
    Error   string                 `json:"error"`
    Code    string                 `json:"code,omitempty"`
    Details map[string]any `json:"details,omitempty"`
    RequestID string             `json:"request_id,omitempty"`
}

// Error codes
const (
    ErrInvalidInput     = "INVALID_INPUT"
    ErrNotFound         = "NOT_FOUND"
    ErrUnauthorized     = "UNAUTHORIZED"
    ErrRateLimitExceeded = "RATE_LIMIT_EXCEEDED"
    ErrContentTooLarge  = "CONTENT_TOO_LARGE"
)
```

### HTTP Status Code Mapping

- 200: Successful GET requests
- 201: Successful POST (creation)
- 204: Successful DELETE
- 400: Bad request (validation errors)
- 401: Unauthorized (missing/invalid auth)
- 403: Forbidden (accessing other user's data)
- 404: Resource not found
- 413: Content too large
- 429: Rate limit exceeded
- 500: Internal server error

## Configuration

### Environment Variables

```env
# API Configuration
API_MAX_REQUEST_SIZE=10MB
API_DEFAULT_PAGE_SIZE=20
API_MAX_PAGE_SIZE=100
API_CONTENT_MAX_SIZE=50KB
API_METADATA_MAX_SIZE=10KB

# Rate Limiting
RATE_LIMIT_CREATE_JOURNAL=20/minute
RATE_LIMIT_GET_JOURNALS=60/minute
RATE_LIMIT_UPDATE_JOURNAL=10/minute
RATE_LIMIT_DELETE_JOURNAL=5/minute

# Security
CORS_ALLOWED_ORIGINS=http://localhost:3000
CORS_ALLOWED_HEADERS=Authorization,Content-Type
```

## API Documentation

### OpenAPI Specification

```yaml
openapi: 3.0.0
info:
  title: EngLog Journal API
  version: 1.0.0
  description: Personal journaling with AI insights

paths:
  /api/journals:
    get:
      summary: List user journals
      security:
        - BearerAuth: []
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: page_size
          in: query
          schema:
            type: integer
            default: 20
            maximum: 100
      responses:
        200:
          description: List of journals
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ListJournalsResponse"
```

## Migration from Phase 0

### API Changes

1. **Authentication Required:** Add JWT middleware to all endpoints
2. **User Context:** Filter data by authenticated user
3. **Validation Enhanced:** Add comprehensive input validation
4. **Error Handling:** Implement standardized error responses
5. **Rate Limiting:** Add request throttling

### Data Migration

- Associate existing prototype data with default user
- Ensure user_id field populated in all records
- Validate data integrity after migration

## Dependencies

### External Dependencies

- Gin web framework
- JWT authentication middleware (MVP-003)
- Input validation library
- Rate limiting library

### Internal Dependencies

- Journal service layer (MVP-007)
- User context from authentication
- Database repository layer
- Logging and monitoring

## Deliverables

1. **REST API Handlers:** Complete CRUD API implementation
2. **Input Validation:** Comprehensive validation system
3. **Rate Limiting:** Request throttling configuration
4. **Error Handling:** Standardized error responses
5. **API Documentation:** OpenAPI specification
6. **Tests:** Unit and integration test suite

## Definition of Done

- [ ] All journal CRUD endpoints implemented and authenticated
- [ ] User data isolation working correctly
- [ ] Input validation and sanitization functional
- [ ] Rate limiting configured and tested
- [ ] Error handling consistent across all endpoints
- [ ] API documentation complete and accurate
- [ ] Unit and integration tests passing (85%+ coverage)
- [ ] Manual testing completed with various scenarios
- [ ] Code review completed and approved

---

**Estimated Timeline:** 4 days
**Risk Level:** Medium (API security and validation complexity)
**Blockers:** MVP-003 (Authentication), MVP-007 (Journal Data Models)
**Follow-up Tasks:** MVP-015 (Journal Management Interface), MVP-017 (Security Middleware)
