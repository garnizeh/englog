# MVP-003: JWT Authentication Service

**Feature:** MVP-AUTH
**Priority:** P0 (Critical)
**Effort:** Large (4 days)
**Dependencies:** MVP-001 (PostgreSQL Database)

## Objective

Implement JWT-based authentication service to secure API endpoints and manage user sessions, establishing the foundation for user management and secure access control.

## Technical Scope

### JWT Implementation

- JWT token generation and validation
- Access and refresh token patterns
- Token signing with RSA keys
- Secure token storage and management
- Token expiration and renewal

### Authentication Middleware

- HTTP middleware for JWT validation
- Protected route enforcement
- User context injection
- Rate limiting integration
- CORS configuration for web clients

### Session Management

- Redis-based session storage
- Session invalidation and cleanup
- Multi-device session support
- Security audit logging

## Acceptance Criteria

### Functional Requirements

- [ ] JWT tokens generated and validated correctly
- [ ] Authentication middleware protects API endpoints
- [ ] Access and refresh token flow implemented
- [ ] Session management with Redis storage
- [ ] User context available in protected routes

### Security Requirements

- [ ] JWT tokens signed with RSA-256 algorithm
- [ ] Secure token expiration times configured
- [ ] Session hijacking protection implemented
- [ ] Audit logging for authentication events
- [ ] Rate limiting on authentication endpoints

### Integration Requirements

- [ ] Middleware integrated with Gin router
- [ ] User data retrieved from PostgreSQL
- [ ] Redis session store operational
- [ ] Error handling for invalid/expired tokens
- [ ] Health checks include authentication status

## Implementation Details

### JWT Service Structure

```go
type JWTService struct {
    accessPrivateKey  *rsa.PrivateKey
    accessPublicKey   *rsa.PublicKey
    refreshPrivateKey *rsa.PrivateKey
    refreshPublicKey  *rsa.PublicKey
    issuer           string
    accessTTL        time.Duration
    refreshTTL       time.Duration
}

type Claims struct {
    UserID   string   `json:"sub"`
    Email    string   `json:"email"`
    Name     string   `json:"name"`
    Scopes   []string `json:"scope"`
    jwt.RegisteredClaims
}

type TokenPair struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    TokenType    string `json:"token_type"`
    ExpiresIn    int64  `json:"expires_in"`
}
```

### Authentication Middleware

```go
func AuthMiddleware(jwtService *JWTService) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "Missing authorization header"})
            c.Abort()
            return
        }

        token := extractBearerToken(authHeader)
        claims, err := jwtService.ValidateToken(token)
        if err != nil {
            c.JSON(401, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }

        // Inject user context
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_scopes", claims.Scopes)

        c.Next()
    }
}
```

### Session Management

```go
type SessionStore struct {
    redis *redis.Client
    ttl   time.Duration
}

type Session struct {
    UserID       string    `json:"user_id"`
    TokenID      string    `json:"token_id"`
    DeviceInfo   string    `json:"device_info"`
    IPAddress    string    `json:"ip_address"`
    CreatedAt    time.Time `json:"created_at"`
    LastActivity time.Time `json:"last_activity"`
}

func (s *SessionStore) CreateSession(userID, tokenID string) error {
    session := &Session{
        UserID:       userID,
        TokenID:      tokenID,
        CreatedAt:    time.Now(),
        LastActivity: time.Now(),
    }

    key := fmt.Sprintf("session:%s:%s", userID, tokenID)
    return s.redis.Set(ctx, key, session, s.ttl).Err()
}
```

### API Endpoints

```
POST /auth/login      # Initial authentication (placeholder for OAuth/OTP)
POST /auth/refresh    # Refresh access token
POST /auth/logout     # Invalidate session
GET  /auth/profile    # Get user profile (protected)
GET  /auth/sessions   # List active sessions (protected)
DELETE /auth/sessions/:id # Revoke specific session (protected)
```

## Testing Strategy

### Unit Tests

- JWT token generation and validation
- Claims encoding and decoding
- Token expiration handling
- Session CRUD operations
- Middleware request processing

### Integration Tests

- End-to-end authentication flow
- Protected endpoint access
- Token refresh scenarios
- Session management operations
- Redis integration testing

### Security Tests

- Token tampering detection
- Expired token rejection
- Invalid signature handling
- Session hijacking prevention
- Rate limiting validation

## Configuration

### Environment Variables

```env
# JWT Configuration
JWT_ACCESS_TTL=15m
JWT_REFRESH_TTL=7d
JWT_ISSUER=api.englog.com
JWT_ACCESS_PRIVATE_KEY_PATH=/keys/access-private.pem
JWT_ACCESS_PUBLIC_KEY_PATH=/keys/access-public.pem
JWT_REFRESH_PRIVATE_KEY_PATH=/keys/refresh-private.pem
JWT_REFRESH_PUBLIC_KEY_PATH=/keys/refresh-public.pem

# Session Configuration
REDIS_URL=redis://localhost:6379
SESSION_TTL=7d

# Security Configuration
CORS_ALLOWED_ORIGINS=http://localhost:3000,https://app.englog.com
RATE_LIMIT_AUTH=10/minute
```

### Key Generation

```bash
# Generate RSA key pairs for JWT signing
openssl genrsa -out access-private.pem 2048
openssl rsa -in access-private.pem -pubout -out access-public.pem

openssl genrsa -out refresh-private.pem 2048
openssl rsa -in refresh-private.pem -pubout -out refresh-public.pem
```

## Security Considerations

### Token Security

- RSA-256 signature algorithm for JWT tokens
- Separate key pairs for access and refresh tokens
- Short access token expiration (15 minutes)
- Longer refresh token expiration (7 days)
- Secure token storage in HTTP-only cookies (frontend)

### Session Security

- Session binding to IP address and User-Agent
- Session invalidation on logout
- Automatic cleanup of expired sessions
- Audit logging for session events

### Rate Limiting

- Authentication endpoint rate limiting
- Brute force protection
- Token refresh rate limiting
- Suspicious activity detection

## Migration from Phase 0

### Authentication Addition

1. **Add Authentication Layer:** All endpoints except health checks require authentication
2. **User Context:** Inject user information into request context
3. **Database Integration:** Link journals to authenticated users
4. **API Changes:** Update endpoints to use user-specific data

### Backwards Compatibility

- Health check endpoints remain public
- Existing journal data structure preserved
- API response formats maintained
- Processing flow unchanged

## Dependencies

### External Dependencies

- Redis for session storage
- RSA key pairs for JWT signing
- Database user table (MVP-001)
- Rate limiting library

### Internal Dependencies

- User repository (MVP-006)
- Logging framework
- Configuration management
- Error handling patterns

## Deliverables

1. **JWT Service:** Complete JWT token management system
2. **Authentication Middleware:** Gin middleware for route protection
3. **Session Management:** Redis-based session storage system
4. **API Endpoints:** Authentication-related API endpoints
5. **Security Configuration:** RSA keys and security settings
6. **Documentation:** Authentication flow and API documentation

## Definition of Done

- [ ] JWT service generating and validating tokens correctly
- [ ] Authentication middleware protecting API endpoints
- [ ] Session management working with Redis
- [ ] Access and refresh token flow functional
- [ ] Rate limiting implemented on auth endpoints
- [ ] Security audit logging operational
- [ ] Unit and integration tests passing (80%+ coverage)
- [ ] Documentation completed with security considerations
- [ ] Code review completed and approved

---

**Estimated Timeline:** 4 days
**Risk Level:** Medium (security implementation complexity)
**Blockers:** MVP-001 (Database required for user storage)
**Follow-up Tasks:** MVP-004 (OAuth Integration), MVP-005 (Email OTP), MVP-006 (User Management)
