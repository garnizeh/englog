# MVP-004: Journal Data Models & Validation

**Feature:** MVP-Backend
**Priority:** P0 (Critical)
**Effort:** Medium (3 days)
**Dependencies:** MVP-001 (PostgreSQL Setup)

## Objective

Define and implement comprehensive data models for journal entries with flexible JSONB schema, validation rules, and database persistence layer supporting the core journaling functionality.

## Technical Scope

### Data Models

- Journal entry core structure
- User profile and preferences
- Metadata and custom fields support
- Validation schemas and rules
- Database mapping and persistence

### Schema Design

- Flexible JSONB content structure
- Relational integrity for core fields
- Full-text search capabilities
- Indexing strategy for performance
- Migration support for schema evolution

### Validation Framework

- Input validation with comprehensive rules
- Custom validation functions
- Error handling and user feedback
- Security sanitization
- Type safety and conversion

## Acceptance Criteria

### Data Model Requirements

- [ ] Journal entry model accepts any JSON content structure
- [ ] Core fields (ID, UserID, CreatedAt) are strongly typed
- [ ] User preferences stored with validation
- [ ] Metadata support for client information
- [ ] Custom fields supported without schema changes

### Validation Requirements

- [ ] Content length limits enforced (max 50,000 characters)
- [ ] Required fields validated before storage
- [ ] Input sanitization prevents XSS attacks
- [ ] Invalid JSON rejected with clear error messages
- [ ] Type validation for structured fields

### Performance Requirements

- [ ] Journal creation under 100ms for typical entries
- [ ] Batch operations support for multiple entries
- [ ] Query performance optimized with proper indexing
- [ ] Full-text search responds under 500ms
- [ ] Database constraints prevent data corruption

## Implementation Details

### Core Data Models

```go
// Journal entry with flexible JSONB content
type JournalEntry struct {
    ID              string                 `json:"id" db:"id"`
    UserID          string                 `json:"user_id" db:"user_id"`
    RawData         map[string]any `json:"raw_data" db:"raw_data"`
    EntryType       string                 `json:"entry_type" db:"entry_type"`
    ProcessingStatus string                `json:"processing_status" db:"processing_status"`
    Metadata        JournalMetadata        `json:"metadata" db:"metadata"`
    CreatedAt       time.Time              `json:"created_at" db:"created_at"`
    UpdatedAt       time.Time              `json:"updated_at" db:"updated_at"`
}

type JournalMetadata struct {
    Source         string                 `json:"source,omitempty"`
    ClientVersion  string                 `json:"client_version,omitempty"`
    IPAddress      string                 `json:"ip_address,omitempty"`
    UserAgent      string                 `json:"user_agent,omitempty"`
    Location       *LocationData          `json:"location,omitempty"`
    WordCount      int                    `json:"word_count,omitempty"`
    ReadingTime    int                    `json:"reading_time_minutes,omitempty"`
    CustomFields   map[string]any `json:"custom_fields,omitempty"`
}

type LocationData struct {
    Latitude    float64 `json:"lat"`
    Longitude   float64 `json:"lng"`
    Accuracy    float64 `json:"accuracy,omitempty"`
    City        string  `json:"city,omitempty"`
    Country     string  `json:"country,omitempty"`
    Timezone    string  `json:"timezone,omitempty"`
}

// User model with preferences
type User struct {
    ID               string                 `json:"id" db:"id"`
    Email            string                 `json:"email" db:"email"`
    Name             string                 `json:"name" db:"name"`
    AuthProvider     string                 `json:"auth_provider" db:"auth_provider"`
    AuthProviderID   string                 `json:"auth_provider_id" db:"auth_provider_id"`
    Status           string                 `json:"status" db:"status"`
    Preferences      UserPreferences        `json:"preferences" db:"preferences"`
    CreatedAt        time.Time              `json:"created_at" db:"created_at"`
    UpdatedAt        time.Time              `json:"updated_at" db:"updated_at"`
    LastLoginAt      *time.Time             `json:"last_login_at" db:"last_login_at"`
}

type UserPreferences struct {
    Timezone         string                 `json:"timezone"`
    Language         string                 `json:"language"`
    DateFormat       string                 `json:"date_format"`
    Theme            string                 `json:"theme"`
    AIProcessing     AIPreferences          `json:"ai_processing"`
    Privacy          PrivacyPreferences     `json:"privacy"`
    Notifications    NotificationPreferences `json:"notifications"`
    CustomSettings   map[string]any `json:"custom_settings,omitempty"`
}

type AIPreferences struct {
    Enabled          bool     `json:"enabled"`
    Providers        []string `json:"providers"`
    AnalysisDepth    string   `json:"analysis_depth"` // "basic", "detailed", "comprehensive"
    AutoProcess      bool     `json:"auto_process"`
    ShareForTraining bool     `json:"share_for_training"`
}

type PrivacyPreferences struct {
    DataSharing      bool `json:"data_sharing"`
    AnalyticsEnabled bool `json:"analytics_enabled"`
    LocationTracking bool `json:"location_tracking"`
    DataRetentionDays int `json:"data_retention_days"`
}

type NotificationPreferences struct {
    EmailInsights       bool `json:"email_insights"`
    ProcessingComplete  bool `json:"processing_complete"`
    WeeklyReports       bool `json:"weekly_reports"`
    SecurityAlerts      bool `json:"security_alerts"`
}

// Constants for validation
const (
    MaxJournalContentLength = 50000
    MinJournalContentLength = 1
    MaxTitleLength          = 200
    MaxTagLength            = 50
    MaxTagsPerEntry         = 20
    MaxCustomFieldKeyLength = 100
    MaxCustomFieldValueLength = 1000
)

type EntryType string

const (
    EntryTypeText   EntryType = "text"
    EntryTypeVoice  EntryType = "voice"
    EntryTypePhoto  EntryType = "photo"
    EntryTypeMixed  EntryType = "mixed"
    EntryTypeImport EntryType = "import"
)

type ProcessingStatus string

const (
    ProcessingStatusPending   ProcessingStatus = "pending"
    ProcessingStatusProcessing ProcessingStatus = "processing"
    ProcessingStatusCompleted ProcessingStatus = "completed"
    ProcessingStatusFailed    ProcessingStatus = "failed"
    ProcessingStatusSkipped   ProcessingStatus = "skipped"
)
```

### Validation Framework

```go
import (
    "github.com/go-playground/validator/v10"
    "github.com/microcosm-cc/bluemonday"
)

type Validator struct {
    validate  *validator.Validate
    sanitizer *bluemonday.Policy
}

func NewValidator() *Validator {
    v := validator.New()

    // Register custom validators
    v.RegisterValidation("journal_content", validateJournalContent)
    v.RegisterValidation("safe_html", validateSafeHTML)
    v.RegisterValidation("entry_type", validateEntryType)
    v.RegisterValidation("json_size", validateJSONSize)

    // Create HTML sanitizer
    sanitizer := bluemonday.StrictPolicy()

    return &Validator{
        validate:  v,
        sanitizer: sanitizer,
    }
}

// Journal entry creation request
type CreateJournalRequest struct {
    Content      string                 `json:"content" validate:"required,min=1,max=50000,journal_content"`
    Title        *string                `json:"title,omitempty" validate:"omitempty,max=200,safe_html"`
    EntryType    string                 `json:"entry_type" validate:"required,entry_type"`
    Tags         []string               `json:"tags,omitempty" validate:"dive,max=50,alphanum"`
    Mood         *int                   `json:"mood,omitempty" validate:"omitempty,min=1,max=10"`
    Location     *LocationData          `json:"location,omitempty"`
    CustomFields map[string]any `json:"custom_fields,omitempty" validate:"dive,keys,max=100,endkeys,json_size"`
    PrivateNotes string                 `json:"private_notes,omitempty" validate:"max=1000"`
}

type UpdateJournalRequest struct {
    Content      *string                `json:"content,omitempty" validate:"omitempty,min=1,max=50000,journal_content"`
    Title        *string                `json:"title,omitempty" validate:"omitempty,max=200,safe_html"`
    Tags         []string               `json:"tags,omitempty" validate:"dive,max=50,alphanum"`
    Mood         *int                   `json:"mood,omitempty" validate:"omitempty,min=1,max=10"`
    Location     *LocationData          `json:"location,omitempty"`
    CustomFields map[string]any `json:"custom_fields,omitempty" validate:"dive,keys,max=100,endkeys,json_size"`
    PrivateNotes *string                `json:"private_notes,omitempty" validate:"omitempty,max=1000"`
}

func (v *Validator) ValidateJournalRequest(req *CreateJournalRequest) error {
    if err := v.validate.Struct(req); err != nil {
        return v.formatValidationErrors(err)
    }

    // Additional custom validation
    if err := v.validateCustomFields(req.CustomFields); err != nil {
        return err
    }

    if err := v.validateContentSafety(req.Content); err != nil {
        return err
    }

    return nil
}

func (v *Validator) SanitizeJournalRequest(req *CreateJournalRequest) {
    // Sanitize text content
    req.Content = v.sanitizer.Sanitize(req.Content)

    if req.Title != nil {
        sanitized := v.sanitizer.Sanitize(*req.Title)
        req.Title = &sanitized
    }

    // Sanitize custom fields
    if req.CustomFields != nil {
        v.sanitizeCustomFields(req.CustomFields)
    }

    // Clean private notes
    req.PrivateNotes = v.sanitizer.Sanitize(req.PrivateNotes)
}

// Custom validators
func validateJournalContent(fl validator.FieldLevel) bool {
    content := fl.Field().String()

    // Check for minimum meaningful content
    cleanContent := strings.TrimSpace(content)
    if len(cleanContent) < MinJournalContentLength {
        return false
    }

    // Check for suspicious patterns
    suspiciousPatterns := []string{
        "javascript:", "data:", "vbscript:",
        "<script", "<iframe", "<object", "<embed",
    }

    lowerContent := strings.ToLower(content)
    for _, pattern := range suspiciousPatterns {
        if strings.Contains(lowerContent, pattern) {
            return false
        }
    }

    return true
}

func validateSafeHTML(fl validator.FieldLevel) bool {
    content := fl.Field().String()

    // Basic HTML safety check
    if strings.Contains(content, "<script") ||
       strings.Contains(content, "javascript:") ||
       strings.Contains(content, "vbscript:") {
        return false
    }

    return true
}

func validateEntryType(fl validator.FieldLevel) bool {
    entryType := fl.Field().String()

    validTypes := []string{
        string(EntryTypeText),
        string(EntryTypeVoice),
        string(EntryTypePhoto),
        string(EntryTypeMixed),
        string(EntryTypeImport),
    }

    for _, valid := range validTypes {
        if entryType == valid {
            return true
        }
    }

    return false
}

func validateJSONSize(fl validator.FieldLevel) bool {
    value := fl.Field().Interface()

    jsonData, err := json.Marshal(value)
    if err != nil {
        return false
    }

    // Limit custom field values to reasonable size
    return len(jsonData) <= MaxCustomFieldValueLength
}

func (v *Validator) validateCustomFields(fields map[string]any) error {
    if len(fields) > MaxTagsPerEntry {
        return fmt.Errorf("too many custom fields: maximum %d allowed", MaxTagsPerEntry)
    }

    for key, value := range fields {
        if len(key) > MaxCustomFieldKeyLength {
            return fmt.Errorf("custom field key too long: maximum %d characters", MaxCustomFieldKeyLength)
        }

        // Validate value size
        jsonValue, err := json.Marshal(value)
        if err != nil {
            return fmt.Errorf("invalid custom field value for key %s: %w", key, err)
        }

        if len(jsonValue) > MaxCustomFieldValueLength {
            return fmt.Errorf("custom field value too large for key %s: maximum %d bytes", key, MaxCustomFieldValueLength)
        }
    }

    return nil
}

func (v *Validator) formatValidationErrors(err error) error {
    var validationErrors []string

    if errs, ok := err.(validator.ValidationErrors); ok {
        for _, e := range errs {
            switch e.Tag() {
            case "required":
                validationErrors = append(validationErrors, fmt.Sprintf("%s is required", e.Field()))
            case "min":
                validationErrors = append(validationErrors, fmt.Sprintf("%s must be at least %s characters", e.Field(), e.Param()))
            case "max":
                validationErrors = append(validationErrors, fmt.Sprintf("%s must be at most %s characters", e.Field(), e.Param()))
            case "journal_content":
                validationErrors = append(validationErrors, "content contains invalid or unsafe characters")
            case "entry_type":
                validationErrors = append(validationErrors, "invalid entry type")
            default:
                validationErrors = append(validationErrors, fmt.Sprintf("%s is invalid", e.Field()))
            }
        }
    }

    return fmt.Errorf("validation failed: %s", strings.Join(validationErrors, ", "))
}
```

### Database Repository Layer

```go
type JournalRepository interface {
    Create(ctx context.Context, journal *JournalEntry) error
    GetByID(ctx context.Context, id string) (*JournalEntry, error)
    GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*JournalEntry, error)
    Update(ctx context.Context, journal *JournalEntry) error
    Delete(ctx context.Context, id string) error
    Search(ctx context.Context, userID, query string, limit, offset int) ([]*JournalEntry, error)
    GetByDateRange(ctx context.Context, userID string, start, end time.Time) ([]*JournalEntry, error)
    Count(ctx context.Context, userID string) (int, error)
}

type PostgreSQLJournalRepository struct {
    db     *sql.DB
    logger *slog.Logger
}

func NewPostgreSQLJournalRepository(db *sql.DB, logger *slog.Logger) *PostgreSQLJournalRepository {
    return &PostgreSQLJournalRepository{
        db:     db,
        logger: logger,
    }
}

func (r *PostgreSQLJournalRepository) Create(ctx context.Context, journal *JournalEntry) error {
    query := `
        INSERT INTO journal_entries (id, user_id, raw_data, entry_type, processing_status, metadata, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `

    metadataJSON, err := json.Marshal(journal.Metadata)
    if err != nil {
        return fmt.Errorf("failed to marshal metadata: %w", err)
    }

    rawDataJSON, err := json.Marshal(journal.RawData)
    if err != nil {
        return fmt.Errorf("failed to marshal raw data: %w", err)
    }

    _, err = r.db.ExecContext(ctx, query,
        journal.ID,
        journal.UserID,
        rawDataJSON,
        journal.EntryType,
        journal.ProcessingStatus,
        metadataJSON,
        journal.CreatedAt,
        journal.UpdatedAt,
    )

    if err != nil {
        r.logger.Error("Failed to create journal entry",
            "error", err,
            "journal_id", journal.ID,
            "user_id", journal.UserID)
        return fmt.Errorf("failed to create journal entry: %w", err)
    }

    r.logger.Info("Journal entry created",
        "journal_id", journal.ID,
        "user_id", journal.UserID,
        "entry_type", journal.EntryType)

    return nil
}

func (r *PostgreSQLJournalRepository) GetByID(ctx context.Context, id string) (*JournalEntry, error) {
    query := `
        SELECT id, user_id, raw_data, entry_type, processing_status, metadata, created_at, updated_at
        FROM journal_entries
        WHERE id = $1
    `

    var journal JournalEntry
    var rawDataBytes, metadataBytes []byte

    err := r.db.QueryRowContext(ctx, query, id).Scan(
        &journal.ID,
        &journal.UserID,
        &rawDataBytes,
        &journal.EntryType,
        &journal.ProcessingStatus,
        &metadataBytes,
        &journal.CreatedAt,
        &journal.UpdatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, ErrJournalNotFound
        }
        return nil, fmt.Errorf("failed to get journal entry: %w", err)
    }

    // Unmarshal JSON fields
    if err := json.Unmarshal(rawDataBytes, &journal.RawData); err != nil {
        return nil, fmt.Errorf("failed to unmarshal raw data: %w", err)
    }

    if err := json.Unmarshal(metadataBytes, &journal.Metadata); err != nil {
        return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
    }

    return &journal, nil
}

func (r *PostgreSQLJournalRepository) GetByUserID(ctx context.Context, userID string, limit, offset int) ([]*JournalEntry, error) {
    query := `
        SELECT id, user_id, raw_data, entry_type, processing_status, metadata, created_at, updated_at
        FROM journal_entries
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
    `

    rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
    if err != nil {
        return nil, fmt.Errorf("failed to query journal entries: %w", err)
    }
    defer rows.Close()

    var journals []*JournalEntry

    for rows.Next() {
        var journal JournalEntry
        var rawDataBytes, metadataBytes []byte

        err := rows.Scan(
            &journal.ID,
            &journal.UserID,
            &rawDataBytes,
            &journal.EntryType,
            &journal.ProcessingStatus,
            &metadataBytes,
            &journal.CreatedAt,
            &journal.UpdatedAt,
        )

        if err != nil {
            return nil, fmt.Errorf("failed to scan journal entry: %w", err)
        }

        // Unmarshal JSON fields
        if err := json.Unmarshal(rawDataBytes, &journal.RawData); err != nil {
            r.logger.Warn("Failed to unmarshal raw data", "journal_id", journal.ID, "error", err)
            continue
        }

        if err := json.Unmarshal(metadataBytes, &journal.Metadata); err != nil {
            r.logger.Warn("Failed to unmarshal metadata", "journal_id", journal.ID, "error", err)
            continue
        }

        journals = append(journals, &journal)
    }

    return journals, nil
}

func (r *PostgreSQLJournalRepository) Search(ctx context.Context, userID, query string, limit, offset int) ([]*JournalEntry, error) {
    sqlQuery := `
        SELECT id, user_id, raw_data, entry_type, processing_status, metadata, created_at, updated_at,
               ts_rank(to_tsvector('english', COALESCE(raw_data->>'content', '')), plainto_tsquery('english', $2)) as rank
        FROM journal_entries
        WHERE user_id = $1
        AND to_tsvector('english', COALESCE(raw_data->>'content', '')) @@ plainto_tsquery('english', $2)
        ORDER BY rank DESC, created_at DESC
        LIMIT $3 OFFSET $4
    `

    rows, err := r.db.QueryContext(ctx, sqlQuery, userID, query, limit, offset)
    if err != nil {
        return nil, fmt.Errorf("failed to search journal entries: %w", err)
    }
    defer rows.Close()

    var journals []*JournalEntry

    for rows.Next() {
        var journal JournalEntry
        var rawDataBytes, metadataBytes []byte
        var rank float64

        err := rows.Scan(
            &journal.ID,
            &journal.UserID,
            &rawDataBytes,
            &journal.EntryType,
            &journal.ProcessingStatus,
            &metadataBytes,
            &journal.CreatedAt,
            &journal.UpdatedAt,
            &rank,
        )

        if err != nil {
            return nil, fmt.Errorf("failed to scan search result: %w", err)
        }

        // Unmarshal JSON fields
        if err := json.Unmarshal(rawDataBytes, &journal.RawData); err != nil {
            continue
        }

        if err := json.Unmarshal(metadataBytes, &journal.Metadata); err != nil {
            continue
        }

        journals = append(journals, &journal)
    }

    return journals, nil
}

func (r *PostgreSQLJournalRepository) Update(ctx context.Context, journal *JournalEntry) error {
    query := `
        UPDATE journal_entries
        SET raw_data = $2, entry_type = $3, processing_status = $4, metadata = $5, updated_at = $6
        WHERE id = $1
    `

    metadataJSON, err := json.Marshal(journal.Metadata)
    if err != nil {
        return fmt.Errorf("failed to marshal metadata: %w", err)
    }

    rawDataJSON, err := json.Marshal(journal.RawData)
    if err != nil {
        return fmt.Errorf("failed to marshal raw data: %w", err)
    }

    result, err := r.db.ExecContext(ctx, query,
        journal.ID,
        rawDataJSON,
        journal.EntryType,
        journal.ProcessingStatus,
        metadataJSON,
        time.Now(),
    )

    if err != nil {
        return fmt.Errorf("failed to update journal entry: %w", err)
    }

    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }

    if rowsAffected == 0 {
        return ErrJournalNotFound
    }

    return nil
}
```

### Error Definitions

```go
var (
    ErrJournalNotFound      = errors.New("journal entry not found")
    ErrInvalidJournalData   = errors.New("invalid journal data")
    ErrContentTooLong       = errors.New("journal content exceeds maximum length")
    ErrContentTooShort      = errors.New("journal content is too short")
    ErrInvalidEntryType     = errors.New("invalid entry type")
    ErrInvalidUserID        = errors.New("invalid user ID")
    ErrDuplicateJournal     = errors.New("journal entry already exists")
    ErrUnsafeContent        = errors.New("content contains unsafe elements")
)

type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
    Value   any    `json:"value,omitempty"`
}

type ValidationErrors struct {
    Errors []ValidationError `json:"errors"`
}

func (ve ValidationErrors) Error() string {
    var messages []string
    for _, err := range ve.Errors {
        messages = append(messages, fmt.Sprintf("%s: %s", err.Field, err.Message))
    }
    return strings.Join(messages, "; ")
}
```

## Testing Strategy

### Unit Tests

- Data model validation rules
- JSON serialization/deserialization
- Custom validator functions
- Repository CRUD operations
- Error handling scenarios

### Integration Tests

- Database persistence and retrieval
- Full-text search functionality
- Data integrity constraints
- Performance with large datasets
- Migration compatibility

### Validation Tests

- Content length limits
- XSS prevention
- Input sanitization
- Custom field validation
- Error message accuracy

## Configuration

### Database Schema

```sql
-- Create journal entries table with JSONB support
CREATE TABLE journal_entries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    raw_data JSONB NOT NULL,
    entry_type VARCHAR(20) NOT NULL DEFAULT 'text',
    processing_status VARCHAR(20) NOT NULL DEFAULT 'pending',
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_journal_entries_user_id ON journal_entries(user_id);
CREATE INDEX idx_journal_entries_created_at ON journal_entries(created_at);
CREATE INDEX idx_journal_entries_processing_status ON journal_entries(processing_status);
CREATE INDEX idx_journal_entries_entry_type ON journal_entries(entry_type);

-- Full-text search index
CREATE INDEX idx_journal_entries_content_search ON journal_entries
USING GIN (to_tsvector('english', COALESCE(raw_data->>'content', '')));

-- JSONB indexes for common queries
CREATE INDEX idx_journal_entries_raw_data_gin ON journal_entries USING GIN(raw_data);
CREATE INDEX idx_journal_entries_metadata_gin ON journal_entries USING GIN(metadata);

-- Partial indexes for specific use cases
CREATE INDEX idx_journal_entries_pending ON journal_entries(user_id, created_at)
WHERE processing_status = 'pending';

-- Constraints
ALTER TABLE journal_entries ADD CONSTRAINT check_entry_type
CHECK (entry_type IN ('text', 'voice', 'photo', 'mixed', 'import'));

ALTER TABLE journal_entries ADD CONSTRAINT check_processing_status
CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed', 'skipped'));

-- Trigger for updating updated_at
CREATE OR REPLACE FUNCTION update_journal_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_journal_updated_at
    BEFORE UPDATE ON journal_entries
    FOR EACH ROW
    EXECUTE FUNCTION update_journal_updated_at();
```

## Dependencies

### External Dependencies

- PostgreSQL 17+ with JSONB support
- go-playground/validator for validation
- microcosm-cc/bluemonday for HTML sanitization
- google/uuid for ID generation

### Internal Dependencies

- Database connection (MVP-001)
- User authentication models
- Logging infrastructure
- Error handling framework

## Deliverables

1. **Data Models:** Complete Go structs with JSON tags
2. **Validation Framework:** Comprehensive input validation
3. **Repository Layer:** Database persistence with CRUD operations
4. **Migration Scripts:** Database schema creation and indexes
5. **Test Suite:** Unit and integration tests
6. **Documentation:** API documentation and usage examples

## Definition of Done

- [ ] Journal entry model supports flexible JSONB content
- [ ] Validation prevents malicious and invalid input
- [ ] Repository layer handles all CRUD operations
- [ ] Full-text search works with PostgreSQL
- [ ] Database indexes optimize query performance
- [ ] Input sanitization prevents XSS attacks
- [ ] Custom fields support without schema changes
- [ ] Error handling provides clear user feedback
- [ ] Unit tests achieve 95%+ coverage
- [ ] Integration tests validate database operations
- [ ] Performance tests meet latency requirements (<100ms creation)
- [ ] Migration scripts support schema evolution
- [ ] Documentation covers all public APIs

---

**Estimated Timeline:** 3 days
**Risk Level:** Medium (data validation complexity)
**Blockers:** MVP-001 (PostgreSQL Setup)
**Follow-up Tasks:** MVP-005 (Journal Service Layer), MVP-008 (Authenticated API)
