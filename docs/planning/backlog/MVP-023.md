# MVP-023: CI/CD Pipeline Implementation

**Task ID:** MVP-023
**Feature Area:** MVP-DEVOPS
**Priority:** P2 (Medium)
**Effort Estimate:** 4 days
**Dependencies:** MVP-022 (Docker Compose Production Setup)

## Objective

Implement comprehensive CI/CD pipeline with automated testing, security scanning, quality gates, and deployment automation to ensure reliable and efficient software delivery with zero-downtime deployments.

## Business Context

A robust CI/CD pipeline reduces manual deployment errors, accelerates time-to-market, ensures consistent quality through automated testing, and enables rapid response to issues through automated rollbacks. This is essential for maintaining high-quality software delivery.

## Technical Requirements

### Core Pipeline Components

1. **Continuous Integration**

   - Automated build and test execution
   - Code quality analysis and security scanning
   - Artifact generation and registry management
   - Multi-environment validation

2. **Continuous Deployment**

   - Automated deployment to staging/production
   - Blue-green deployment strategy
   - Database migration automation
   - Rollback capabilities

3. **Quality Gates**

   - Test coverage requirements
   - Security vulnerability scanning
   - Performance regression detection
   - Code quality thresholds

4. **Monitoring & Notifications**
   - Pipeline status tracking
   - Deployment notifications
   - Failure alerting
   - Performance monitoring

## Implementation Specification

### GitHub Actions Workflow

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Code Quality and Security Checks
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Run go vet
        run: go vet ./...

      - name: Run staticcheck
        uses: dominikh/staticcheck-action@v1.3.0
        with:
          version: "2023.1.6"

      - name: Run gosec security scanner
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: "-fmt sarif -out gosec.sarif ./..."

      - name: Upload gosec results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec.sarif

      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

  # Unit Tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: englog_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Install dependencies
        run: go mod download

      - name: Run database migrations
        run: |
          go install github.com/golang-migrate/migrate/v4/cmd/migrate@latest
          migrate -path ./migrations -database "postgres://testuser:testpass@localhost:5432/englog_test?sslmode=disable" up
        env:
          DATABASE_URL: postgres://testuser:testpass@localhost:5432/englog_test?sslmode=disable

      - name: Run unit tests
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        env:
          DB_URL: postgres://testuser:testpass@localhost:5432/englog_test?sslmode=disable
          REDIS_URL: redis://localhost:6379
          TEST_ENV: true

      - name: Generate coverage report
        run: |
          go tool cover -html=coverage.out -o coverage.html
          go tool cover -func=coverage.out | grep total | awk '{print $3}' > coverage.txt

      - name: Check coverage threshold
        run: |
          COVERAGE=$(cat coverage.txt | sed 's/%//')
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "Coverage $COVERAGE% is below threshold of 80%"
            exit 1
          fi
          echo "Coverage: $COVERAGE%"

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

      - name: Archive coverage results
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html

  # Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test environment
        run: |
          docker-compose -f docker-compose.test.yml build
          docker-compose -f docker-compose.test.yml up -d

      - name: Wait for services
        run: |
          timeout 120s bash -c 'until docker-compose -f docker-compose.test.yml ps | grep healthy; do sleep 5; done'

      - name: Run integration tests
        run: |
          docker-compose -f docker-compose.test.yml exec -T api go test -tags=integration ./test/integration/...

      - name: Run API tests
        run: |
          docker-compose -f docker-compose.test.yml exec -T api go test -tags=api ./test/api/...

      - name: Collect logs
        if: failure()
        run: |
          mkdir -p logs
          docker-compose -f docker-compose.test.yml logs > logs/integration-tests.log

      - name: Upload logs
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: integration-test-logs
          path: logs/

      - name: Cleanup
        if: always()
        run: docker-compose -f docker-compose.test.yml down -v

  # Build and Push Images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    if: github.event_name == 'push' || github.event_name == 'release'

    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      worker-image: ${{ steps.meta-worker.outputs.tags }}
      version: ${{ steps.meta-api.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Extract metadata for Worker
        id: meta-worker
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/worker
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.api
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Build and push Worker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.worker
          push: true
          tags: ${{ steps.meta-worker.outputs.tags }}
          labels: ${{ steps.meta-worker.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Run security scan on images
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
            ${{ steps.meta-api.outputs.tags }}

          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
            ${{ steps.meta-worker.outputs.tags }}

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to staging
        run: |
          # Update Docker Compose with new image tags
          sed -i "s|image: .*api:.*|image: ${{ needs.build-and-push.outputs.api-image }}|" docker-compose.staging.yml
          sed -i "s|image: .*worker:.*|image: ${{ needs.build-and-push.outputs.worker-image }}|" docker-compose.staging.yml

          # Deploy to staging environment
          ./scripts/deploy-staging.sh

      - name: Run smoke tests
        run: |
          sleep 60  # Wait for deployment
          ./scripts/smoke-tests.sh staging

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: "#deployments"
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          message: "Staging deployment completed: ${{ needs.build-and-push.outputs.version }}"

  # Performance Tests
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Artillery
        run: npm install -g artillery@latest

      - name: Run load tests
        run: |
          artillery run --environment staging test/performance/load-test.yml --output staging-results.json

      - name: Generate performance report
        run: |
          artillery report staging-results.json --output staging-performance.html

      - name: Upload performance report
        uses: actions/upload-artifact@v3
        with:
          name: performance-report-staging
          path: staging-performance.html

      - name: Check performance thresholds
        run: |
          # Extract key metrics and validate against thresholds
          P95_RESPONSE_TIME=$(cat staging-results.json | jq '.aggregate.latency.p95')
          ERROR_RATE=$(cat staging-results.json | jq '.aggregate.counters["errors.total"] // 0')

          if (( $(echo "$P95_RESPONSE_TIME > 2000" | bc -l) )); then
            echo "Performance regression: P95 response time $P95_RESPONSE_TIME ms > 2000ms"
            exit 1
          fi

          if (( $ERROR_RATE > 0 )); then
            echo "Performance regression: Error rate $ERROR_RATE > 0"
            exit 1
          fi

          echo "Performance tests passed: P95=${P95_RESPONSE_TIME}ms, Errors=${ERROR_RATE}"

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, performance-tests]
    if: github.event_name == 'release'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment',
              auto_merge: false
            });
            return deployment.data.id;

      - name: Blue-Green Deployment
        run: |
          # Update images for production
          sed -i "s|image: .*api:.*|image: ${{ needs.build-and-push.outputs.api-image }}|" docker-compose.prod.yml
          sed -i "s|image: .*worker:.*|image: ${{ needs.build-and-push.outputs.worker-image }}|" docker-compose.prod.yml

          # Execute blue-green deployment
          ./scripts/blue-green-deploy.sh

      - name: Run production health checks
        run: |
          sleep 120  # Wait for deployment stabilization
          ./scripts/health-check-production.sh

      - name: Update deployment status - Success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Production deployment successful',
              environment_url: 'https://englog.com'
            });

      - name: Update deployment status - Failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Production deployment failed'
            });

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Production deployment failed, initiating rollback..."
          ./scripts/rollback-production.sh

      - name: Notify production deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: "#production"
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          message: "Production deployment ${{ job.status }}: ${{ needs.build-and-push.outputs.version }}"

  # Security Scanning
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push'

    steps:
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ needs.build-and-push.outputs.api-image }}
          args: --severity-threshold=high

      - name: Run OWASP ZAP scan
        if: github.ref == 'refs/heads/develop'
        run: |
          docker run -v $(pwd):/zap/wrk/:rw \
            owasp/zap2docker-stable zap-baseline.py \
            -t https://staging.englog.com \
            -r zap-report.html

      - name: Upload ZAP report
        if: github.ref == 'refs/heads/develop'
        uses: actions/upload-artifact@v3
        with:
          name: zap-security-report
          path: zap-report.html
```

### Deployment Scripts

```bash
#!/bin/bash
# scripts/deploy-staging.sh
set -euo pipefail

ENVIRONMENT="staging"
COMPOSE_FILE="docker-compose.staging.yml"

echo "🚀 Deploying to staging environment..."

# Load environment variables
if [[ -f ".env.${ENVIRONMENT}" ]]; then
    export $(cat ".env.${ENVIRONMENT}" | xargs)
fi

# Pre-deployment checks
echo "🔍 Running pre-deployment checks..."
if ! docker-compose -f "$COMPOSE_FILE" config > /dev/null; then
    echo "❌ Docker Compose configuration is invalid"
    exit 1
fi

# Database migration
echo "📊 Running database migrations..."
docker-compose -f "$COMPOSE_FILE" run --rm api \
    ./englog-api migrate --config-file=/app/config/staging.yml

# Deploy services
echo "🎬 Deploying services..."
docker-compose -f "$COMPOSE_FILE" pull
docker-compose -f "$COMPOSE_FILE" up -d

# Wait for health checks
echo "⏳ Waiting for services to be healthy..."
timeout 300 bash -c '
    until docker-compose -f '"$COMPOSE_FILE"' ps | grep -q "healthy"; do
        echo "Waiting for services to be healthy..."
        sleep 10
    done
'

# Verify deployment
echo "✅ Verifying deployment..."
./scripts/smoke-tests.sh staging

echo "🎉 Staging deployment completed successfully!"
```

```bash
#!/bin/bash
# scripts/blue-green-deploy.sh
set -euo pipefail

ENVIRONMENT="production"
COMPOSE_FILE="docker-compose.prod.yml"
BLUE_COMPOSE_FILE="docker-compose.blue.yml"
GREEN_COMPOSE_FILE="docker-compose.green.yml"

echo "🔵🟢 Starting blue-green deployment..."

# Determine current environment
CURRENT_ENV=$(curl -s https://api.englog.com/health | jq -r '.environment // "blue"')
if [[ "$CURRENT_ENV" == "blue" ]]; then
    NEW_ENV="green"
    NEW_COMPOSE_FILE="$GREEN_COMPOSE_FILE"
    OLD_COMPOSE_FILE="$BLUE_COMPOSE_FILE"
else
    NEW_ENV="blue"
    NEW_COMPOSE_FILE="$BLUE_COMPOSE_FILE"
    OLD_COMPOSE_FILE="$GREEN_COMPOSE_FILE"
fi

echo "🎯 Current environment: $CURRENT_ENV"
echo "🎯 Deploying to: $NEW_ENV"

# Generate new environment compose file
cp "$COMPOSE_FILE" "$NEW_COMPOSE_FILE"
sed -i "s/container_name: \(.*\)/container_name: \1-$NEW_ENV/" "$NEW_COMPOSE_FILE"
sed -i "s/- \"80:80\"/- \"8080:80\"/" "$NEW_COMPOSE_FILE"  # Use different port initially

# Deploy new environment
echo "🚀 Deploying $NEW_ENV environment..."
docker-compose -f "$NEW_COMPOSE_FILE" pull
docker-compose -f "$NEW_COMPOSE_FILE" up -d

# Wait for new environment to be healthy
echo "⏳ Waiting for $NEW_ENV environment to be healthy..."
timeout 300 bash -c '
    until curl -s http://localhost:8080/health | grep -q "healthy"; do
        echo "Waiting for '"$NEW_ENV"' environment..."
        sleep 10
    done
'

# Run health checks on new environment
echo "🏥 Running health checks on $NEW_ENV environment..."
if ! ./scripts/health-check.sh "http://localhost:8080"; then
    echo "❌ Health checks failed for $NEW_ENV environment"
    docker-compose -f "$NEW_COMPOSE_FILE" down
    exit 1
fi

# Switch traffic
echo "🔀 Switching traffic to $NEW_ENV environment..."
# Update load balancer to point to new environment
sed -i "s/- \"80:80\"/- \"8080:80\"/" "$OLD_COMPOSE_FILE" 2>/dev/null || true
sed -i "s/- \"8080:80\"/- \"80:80\"/" "$NEW_COMPOSE_FILE"

docker-compose -f "$NEW_COMPOSE_FILE" up -d

# Wait for traffic switch
sleep 30

# Verify new environment is receiving traffic
echo "✅ Verifying traffic switch..."
HEALTH_CHECK=$(curl -s https://api.englog.com/health | jq -r '.environment')
if [[ "$HEALTH_CHECK" != "$NEW_ENV" ]]; then
    echo "❌ Traffic switch verification failed"
    exit 1
fi

# Cleanup old environment
echo "🧹 Cleaning up $CURRENT_ENV environment..."
docker-compose -f "$OLD_COMPOSE_FILE" down

echo "🎉 Blue-green deployment completed successfully!"
echo "🎯 Active environment: $NEW_ENV"
```

```bash
#!/bin/bash
# scripts/smoke-tests.sh
set -euo pipefail

ENVIRONMENT="${1:-staging}"
if [[ "$ENVIRONMENT" == "staging" ]]; then
    BASE_URL="https://staging.englog.com"
    API_URL="https://api-staging.englog.com"
else
    BASE_URL="https://englog.com"
    API_URL="https://api.englog.com"
fi

echo "🔍 Running smoke tests for $ENVIRONMENT environment..."

# Test 1: Health endpoint
echo "Testing health endpoint..."
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health")
if [[ "$HTTP_CODE" != "200" ]]; then
    echo "❌ Health check failed (HTTP $HTTP_CODE)"
    exit 1
fi
echo "✅ Health check passed"

# Test 2: Database connectivity
echo "Testing database connectivity..."
DB_STATUS=$(curl -s "$API_URL/health/db" | jq -r '.status')
if [[ "$DB_STATUS" != "healthy" ]]; then
    echo "❌ Database connectivity test failed"
    exit 1
fi
echo "✅ Database connectivity test passed"

# Test 3: Authentication endpoint
echo "Testing authentication endpoint..."
AUTH_HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
    -X POST "$API_URL/api/auth/register" \
    -H "Content-Type: application/json" \
    -d '{"email":"smoke-test@example.com","name":"Smoke Test"}')
if [[ "$AUTH_HTTP_CODE" != "201" && "$AUTH_HTTP_CODE" != "409" ]]; then
    echo "❌ Authentication test failed (HTTP $AUTH_HTTP_CODE)"
    exit 1
fi
echo "✅ Authentication test passed"

# Test 4: Frontend accessibility
echo "Testing frontend accessibility..."
FRONTEND_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL")
if [[ "$FRONTEND_CODE" != "200" ]]; then
    echo "❌ Frontend accessibility test failed (HTTP $FRONTEND_CODE)"
    exit 1
fi
echo "✅ Frontend accessibility test passed"

# Test 5: Performance check
echo "Testing API performance..."
RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$API_URL/health")
if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
    echo "⚠️ API response time is slow: ${RESPONSE_TIME}s"
else
    echo "✅ API performance test passed: ${RESPONSE_TIME}s"
fi

echo "🎉 All smoke tests passed for $ENVIRONMENT!"
```

### Quality Gates Configuration

```yaml
# .github/workflows/quality-gates.yml
name: Quality Gates

on:
  pull_request:
    branches: [main, develop]

jobs:
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"

      - name: Run quality checks
        run: |
          # Install quality tools
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest

          # Quality gates
          echo "🔍 Running quality gates..."

          # Cyclomatic complexity check
          COMPLEX_FUNCS=$(gocyclo -over 10 . | wc -l)
          if [[ $COMPLEX_FUNCS -gt 0 ]]; then
            echo "❌ Found $COMPLEX_FUNCS functions with complexity > 10"
            gocyclo -over 10 .
            exit 1
          fi

          # Security issues
          gosec -quiet -fmt json ./... > gosec-report.json
          SECURITY_ISSUES=$(cat gosec-report.json | jq '.Issues | length')
          if [[ $SECURITY_ISSUES -gt 0 ]]; then
            echo "❌ Found $SECURITY_ISSUES security issues"
            cat gosec-report.json | jq '.Issues'
            exit 1
          fi

          echo "✅ All quality gates passed"

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Comment PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let comment = '## 🚀 Quality Gates Report\n\n';

            // Add quality metrics
            comment += '✅ All quality gates passed!\n\n';
            comment += '### Checks Performed\n';
            comment += '- Cyclomatic complexity < 10\n';
            comment += '- No security vulnerabilities\n';
            comment += '- Code coverage > 80%\n';
            comment += '- Static analysis passed\n';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

### Monitoring Integration

```yaml
# .github/workflows/monitoring.yml
name: Deployment Monitoring

on:
  deployment_status:

jobs:
  monitor-deployment:
    if: github.event.deployment_status.state == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Check deployment health
        run: |
          ENVIRONMENT="${{ github.event.deployment.environment }}"

          if [[ "$ENVIRONMENT" == "production" ]]; then
            URL="https://api.englog.com"
          else
            URL="https://api-staging.englog.com"
          fi

          # Monitor for 10 minutes
          for i in {1..20}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL/health")
            if [[ "$HTTP_CODE" != "200" ]]; then
              echo "❌ Health check failed at attempt $i (HTTP $HTTP_CODE)"
              if [[ $i -gt 10 ]]; then
                # Alert and potentially rollback
                curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
                  -H 'Content-type: application/json' \
                  -d '{"text":"🚨 Deployment monitoring alert: Health checks failing in '"$ENVIRONMENT"'"}'
                exit 1
              fi
            fi
            sleep 30
          done

          echo "✅ Deployment monitoring completed successfully"

      - name: Update deployment monitoring
        run: |
          # Send metrics to monitoring system
          curl -X POST "${{ secrets.PROMETHEUS_GATEWAY }}/metrics/job/github-actions" \
            --data-binary 'deployment_success{environment="${{ github.event.deployment.environment }}"} 1'
```

## Acceptance Criteria

### Core Requirements

- [ ] Complete CI/CD pipeline with automated testing and deployment
- [ ] Code quality gates with coverage requirements (80%+)
- [ ] Security scanning integration with vulnerability detection
- [ ] Multi-environment deployment (staging/production)
- [ ] Blue-green deployment strategy for zero-downtime updates
- [ ] Automated rollback capabilities on deployment failures
- [ ] Performance regression detection with automated thresholds
- [ ] Comprehensive logging and monitoring integration

### Pipeline Requirements

- [ ] Automated build and test execution on every commit
- [ ] Docker image building and registry management
- [ ] Database migration automation
- [ ] Smoke tests execution after deployment
- [ ] Notification system for deployment status
- [ ] Artifact management and versioning
- [ ] Environment-specific configuration management
- [ ] Secret management integration

### Quality Requirements

- [ ] Test coverage reports and threshold enforcement
- [ ] Static code analysis and security scanning
- [ ] Performance testing integration
- [ ] Documentation updates automated
- [ ] Dependency vulnerability scanning
- [ ] Code complexity analysis
- [ ] SonarCloud integration for code quality metrics
- [ ] Pull request quality gates and reviews

### Operational Requirements

- [ ] Deployment monitoring and health checks
- [ ] Rollback procedures tested and documented
- [ ] Environment parity validation
- [ ] Performance monitoring integration
- [ ] Alert system configuration
- [ ] Metrics collection and dashboards
- [ ] Incident response procedures
- [ ] Change management workflow integration

## Task Dependencies

- **Prerequisite:** MVP-022 (Docker Compose Production Setup)
- **Enables:** Complete automated deployment workflow
- **Integrates:** MVP-019, MVP-020, MVP-021 (Testing frameworks)

## Definition of Done

- [ ] CI/CD pipeline functional with all stages working
- [ ] Quality gates enforced and passing
- [ ] Blue-green deployment tested and documented
- [ ] Security scanning integrated and alert-enabled
- [ ] Performance testing automated with regression detection
- [ ] Monitoring and alerting configured for deployments
- [ ] Rollback procedures tested and validated
- [ ] Documentation complete for pipeline operation
- [ ] Team training completed on CI/CD processes
- [ ] Production deployment successful via pipeline

## Notes

- Use environment-specific secrets and configurations
- Implement proper artifact versioning and tagging
- Consider using GitHub Environments for deployment approvals
- Integrate with monitoring tools for deployment visibility
- Establish clear rollback criteria and automated triggers
- Document emergency procedures for manual intervention
