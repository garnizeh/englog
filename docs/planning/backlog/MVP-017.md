# MVP-017: Rate Limiting & Security Middleware

**Feature Area:** MVP-API (API Layer)
**Priority:** P1 (High)
**Effort:** Medium (2 days)
**Dependencies:** MVP-008 (Authenticated Journal CRUD API)

## Overview

Implement comprehensive rate limiting and security middleware to protect the API from abuse, DDoS attacks, and various security vulnerabilities. This middleware layer will provide multiple protection mechanisms including request throttling, IP blocking, request validation, and security headers.

## Business Context

Security middleware is critical for protecting the application from malicious actors and ensuring reliable service for legitimate users. Rate limiting prevents abuse and helps maintain system performance under load, while security middleware protects against common web vulnerabilities.

## Requirements

### Functional Requirements

1. **Rate Limiting**

   - Per-user request limits (authenticated users)
   - Per-IP request limits (unauthenticated traffic)
   - Endpoint-specific rate limits
   - Sliding window implementation for accuracy

2. **Security Headers**

   - CORS configuration
   - Content Security Policy (CSP)
   - HSTS headers
   - X-Frame-Options protection

3. **Request Validation**

   - Input sanitization
   - Request size limits
   - Content-type validation
   - Malicious request detection

4. **IP Protection**
   - IP allowlist/blocklist support
   - Geolocation-based restrictions
   - Suspicious behavior detection

### Technical Requirements

1. **Redis Integration**

   - Use Redis for distributed rate limiting
   - Sliding window counters
   - Efficient key expiration

2. **Performance**

   - Middleware latency < 5ms per request
   - Minimal memory footprint
   - Efficient cleanup of expired data

3. **Configurability**

   - Environment-based rate limits
   - Runtime configuration updates
   - Granular control per endpoint

4. **Monitoring**
   - Rate limit metrics and alerts
   - Security event logging
   - Performance monitoring

## Implementation

### 1. Rate Limiting Middleware

```go
// middleware/rate_limiter.go
package middleware

import (
    "context"
    "fmt"
    "net/http"
    "strconv"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/redis/go-redis/v9"
    "go.uber.org/zap"
)

type RateLimiter struct {
    redis  *redis.Client
    logger *zap.Logger
    config RateLimitConfig
}

type RateLimitConfig struct {
    // Global limits
    GlobalRPS           int           `mapstructure:"global_rps"`
    GlobalBurst         int           `mapstructure:"global_burst"`

    // Per-user limits (authenticated)
    UserRPM             int           `mapstructure:"user_rpm"`
    UserBurst           int           `mapstructure:"user_burst"`

    // Per-IP limits (unauthenticated)
    IPRPM               int           `mapstructure:"ip_rpm"`
    IPBurst             int           `mapstructure:"ip_burst"`

    // Endpoint-specific limits
    EndpointLimits      map[string]EndpointLimit `mapstructure:"endpoint_limits"`

    // Window settings
    WindowSize          time.Duration `mapstructure:"window_size"`
    CleanupInterval     time.Duration `mapstructure:"cleanup_interval"`

    // Blocking settings
    BlockDuration       time.Duration `mapstructure:"block_duration"`
    SuspiciousThreshold int           `mapstructure:"suspicious_threshold"`
}

type EndpointLimit struct {
    RPM       int `mapstructure:"rpm"`
    Burst     int `mapstructure:"burst"`
    UserRPM   int `mapstructure:"user_rpm"`
    UserBurst int `mapstructure:"user_burst"`
}

type RateLimitResult struct {
    Allowed     bool
    Limit       int
    Remaining   int
    ResetTime   time.Time
    RetryAfter  time.Duration
}

func NewRateLimiter(redis *redis.Client, logger *zap.Logger, config RateLimitConfig) *RateLimiter {
    rl := &RateLimiter{
        redis:  redis,
        logger: logger,
        config: config,
    }

    // Start cleanup routine
    go rl.startCleanup()

    return rl
}

func (rl *RateLimiter) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Skip health checks and metrics endpoints
        if rl.shouldSkip(c.Request.URL.Path) {
            c.Next()
            return
        }

        // Determine client identifier
        clientID := rl.getClientID(c)
        endpoint := rl.getEndpointKey(c.Request.Method, c.Request.URL.Path)

        // Check multiple rate limit tiers
        results := []RateLimitResult{
            rl.checkGlobalLimit(c),
            rl.checkClientLimit(c, clientID),
            rl.checkEndpointLimit(c, endpoint, clientID),
        }

        // Find the most restrictive limit
        for _, result := range results {
            if !result.Allowed {
                rl.handleRateLimited(c, result)
                return
            }
        }

        // Add rate limit headers
        rl.addRateLimitHeaders(c, results)

        c.Next()
    }
}

func (rl *RateLimiter) checkGlobalLimit(c *gin.Context) RateLimitResult {
    key := "rate_limit:global"

    return rl.checkSlidingWindow(
        key,
        rl.config.GlobalRPS,
        rl.config.GlobalBurst,
        time.Second,
    )
}

func (rl *RateLimiter) checkClientLimit(c *gin.Context, clientID string) RateLimitResult {
    isAuthenticated := c.GetString("user_id") != ""

    var rpm, burst int
    if isAuthenticated {
        rpm = rl.config.UserRPM
        burst = rl.config.UserBurst
    } else {
        rpm = rl.config.IPRPM
        burst = rl.config.IPBurst
    }

    key := fmt.Sprintf("rate_limit:client:%s", clientID)

    return rl.checkSlidingWindow(
        key,
        rpm,
        burst,
        time.Minute,
    )
}

func (rl *RateLimiter) checkEndpointLimit(c *gin.Context, endpoint, clientID string) RateLimitResult {
    endpointConfig, exists := rl.config.EndpointLimits[endpoint]
    if !exists {
        return RateLimitResult{Allowed: true}
    }

    isAuthenticated := c.GetString("user_id") != ""

    var rpm, burst int
    if isAuthenticated && endpointConfig.UserRPM > 0 {
        rpm = endpointConfig.UserRPM
        burst = endpointConfig.UserBurst
    } else {
        rpm = endpointConfig.RPM
        burst = endpointConfig.Burst
    }

    key := fmt.Sprintf("rate_limit:endpoint:%s:%s", endpoint, clientID)

    return rl.checkSlidingWindow(
        key,
        rpm,
        burst,
        time.Minute,
    )
}

func (rl *RateLimiter) checkSlidingWindow(key string, limit, burst int, window time.Duration) RateLimitResult {
    ctx := context.Background()
    now := time.Now()
    windowStart := now.Add(-window)

    pipe := rl.redis.Pipeline()

    // Remove expired entries
    pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart.UnixNano()))

    // Count current requests
    pipe.ZCard(ctx, key)

    // Add current request
    pipe.ZAdd(ctx, key, &redis.Z{
        Score:  float64(now.UnixNano()),
        Member: fmt.Sprintf("%d:%s", now.UnixNano(), generateRequestID()),
    })

    // Set expiration
    pipe.Expire(ctx, key, window)

    results, err := pipe.Exec(ctx)
    if err != nil {
        rl.logger.Error("Rate limit check failed", zap.Error(err))
        return RateLimitResult{Allowed: true} // Fail open
    }

    count := results[1].(*redis.IntCmd).Val()

    // Check against limit (allow burst)
    effectiveLimit := int64(limit + burst)
    allowed := count <= effectiveLimit

    if !allowed {
        // Remove the request we just added since it's not allowed
        pipe := rl.redis.Pipeline()
        pipe.ZRemRangeByScore(ctx, key, fmt.Sprintf("%d", now.UnixNano()), fmt.Sprintf("%d", now.UnixNano()))
        pipe.Exec(ctx)
    }

    resetTime := now.Add(window)
    remaining := int(effectiveLimit - count)
    if remaining < 0 {
        remaining = 0
    }

    return RateLimitResult{
        Allowed:    allowed,
        Limit:      int(effectiveLimit),
        Remaining:  remaining,
        ResetTime:  resetTime,
        RetryAfter: time.Until(resetTime),
    }
}

func (rl *RateLimiter) getClientID(c *gin.Context) string {
    // Prefer user ID for authenticated requests
    if userID := c.GetString("user_id"); userID != "" {
        return "user:" + userID
    }

    // Use IP for unauthenticated requests
    return "ip:" + c.ClientIP()
}

func (rl *RateLimiter) getEndpointKey(method, path string) string {
    // Normalize path to handle parameters
    parts := strings.Split(path, "/")
    normalized := make([]string, 0, len(parts))

    for _, part := range parts {
        if part == "" {
            continue
        }

        // Replace UUIDs and IDs with placeholder
        if isUUID(part) || isNumeric(part) {
            normalized = append(normalized, ":id")
        } else {
            normalized = append(normalized, part)
        }
    }

    return fmt.Sprintf("%s:/%s", method, strings.Join(normalized, "/"))
}

func (rl *RateLimiter) shouldSkip(path string) bool {
    skipPaths := []string{
        "/health",
        "/metrics",
        "/ready",
    }

    for _, skipPath := range skipPaths {
        if path == skipPath {
            return true
        }
    }

    return false
}

func (rl *RateLimiter) handleRateLimited(c *gin.Context, result RateLimitResult) {
    rl.logger.Warn("Rate limit exceeded",
        zap.String("client_id", rl.getClientID(c)),
        zap.String("endpoint", c.Request.URL.Path),
        zap.Int("limit", result.Limit),
        zap.Duration("retry_after", result.RetryAfter),
    )

    c.Header("X-RateLimit-Limit", strconv.Itoa(result.Limit))
    c.Header("X-RateLimit-Remaining", "0")
    c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))
    c.Header("Retry-After", strconv.Itoa(int(result.RetryAfter.Seconds())))

    c.JSON(http.StatusTooManyRequests, gin.H{
        "error": "Rate limit exceeded",
        "retry_after": int(result.RetryAfter.Seconds()),
        "limit": result.Limit,
    })
    c.Abort()
}

func (rl *RateLimiter) addRateLimitHeaders(c *gin.Context, results []RateLimitResult) {
    if len(results) == 0 {
        return
    }

    // Use the most restrictive remaining count
    minRemaining := results[0].Remaining
    for _, result := range results[1:] {
        if result.Remaining < minRemaining {
            minRemaining = result.Remaining
        }
    }

    c.Header("X-RateLimit-Remaining", strconv.Itoa(minRemaining))
}

func (rl *RateLimiter) startCleanup() {
    ticker := time.NewTicker(rl.config.CleanupInterval)
    defer ticker.Stop()

    for range ticker.C {
        rl.cleanupExpiredKeys()
    }
}

func (rl *RateLimiter) cleanupExpiredKeys() {
    ctx := context.Background()
    pattern := "rate_limit:*"

    iter := rl.redis.Scan(ctx, 0, pattern, 100).Iterator()
    for iter.Next(ctx) {
        key := iter.Val()

        // Remove entries older than window
        now := time.Now()
        cutoff := now.Add(-rl.config.WindowSize * 2) // Extra buffer

        rl.redis.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", cutoff.UnixNano()))

        // Remove empty keys
        count := rl.redis.ZCard(ctx, key).Val()
        if count == 0 {
            rl.redis.Del(ctx, key)
        }
    }
}

// Utility functions
func generateRequestID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

func isUUID(s string) bool {
    return len(s) == 36 && strings.Count(s, "-") == 4
}

func isNumeric(s string) bool {
    _, err := strconv.Atoi(s)
    return err == nil
}
```

### 2. Security Middleware

```go
// middleware/security.go
package middleware

import (
    "net/http"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "go.uber.org/zap"
)

type SecurityConfig struct {
    // CORS settings
    AllowedOrigins   []string `mapstructure:"allowed_origins"`
    AllowedMethods   []string `mapstructure:"allowed_methods"`
    AllowedHeaders   []string `mapstructure:"allowed_headers"`
    AllowCredentials bool     `mapstructure:"allow_credentials"`
    MaxAge           int      `mapstructure:"max_age"`

    // Content Security Policy
    CSPPolicy        string   `mapstructure:"csp_policy"`

    // Request limits
    MaxRequestSize   int64    `mapstructure:"max_request_size"`
    MaxHeaderSize    int      `mapstructure:"max_header_size"`

    // Security headers
    EnableHSTS       bool     `mapstructure:"enable_hsts"`
    HSTSMaxAge       int      `mapstructure:"hsts_max_age"`
    HSTSSubdomains   bool     `mapstructure:"hsts_subdomains"`

    // IP filtering
    BlockedIPs       []string `mapstructure:"blocked_ips"`
    AllowedIPs       []string `mapstructure:"allowed_ips"`
    BlockedCountries []string `mapstructure:"blocked_countries"`
}

func SecurityMiddleware(config SecurityConfig, logger *zap.Logger) gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // IP filtering
        if !isIPAllowed(c.ClientIP(), config) {
            logger.Warn("Blocked IP access attempt",
                zap.String("ip", c.ClientIP()),
                zap.String("user_agent", c.GetHeader("User-Agent")),
            )
            c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                "error": "Access denied",
            })
            return
        }

        // Request size validation
        if c.Request.ContentLength > config.MaxRequestSize {
            logger.Warn("Request size exceeded",
                zap.Int64("size", c.Request.ContentLength),
                zap.Int64("max_size", config.MaxRequestSize),
                zap.String("ip", c.ClientIP()),
            )
            c.AbortWithStatusJSON(http.StatusRequestEntityTooLarge, gin.H{
                "error": "Request too large",
            })
            return
        }

        // Security headers
        addSecurityHeaders(c, config)

        // CORS handling
        handleCORS(c, config)

        c.Next()
    })
}

func CORSMiddleware(config SecurityConfig) gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        origin := c.GetHeader("Origin")

        // Check if origin is allowed
        if isOriginAllowed(origin, config.AllowedOrigins) {
            c.Header("Access-Control-Allow-Origin", origin)
        } else if len(config.AllowedOrigins) == 1 && config.AllowedOrigins[0] == "*" {
            c.Header("Access-Control-Allow-Origin", "*")
        }

        c.Header("Access-Control-Allow-Methods", strings.Join(config.AllowedMethods, ", "))
        c.Header("Access-Control-Allow-Headers", strings.Join(config.AllowedHeaders, ", "))
        c.Header("Access-Control-Max-Age", fmt.Sprintf("%d", config.MaxAge))

        if config.AllowCredentials {
            c.Header("Access-Control-Allow-Credentials", "true")
        }

        // Handle preflight requests
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }

        c.Next()
    })
}

func ContentValidationMiddleware(logger *zap.Logger) gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // Validate content type for POST/PUT requests
        if c.Request.Method == "POST" || c.Request.Method == "PUT" {
            contentType := c.GetHeader("Content-Type")

            allowedTypes := []string{
                "application/json",
                "multipart/form-data",
                "application/x-www-form-urlencoded",
            }

            if !isContentTypeAllowed(contentType, allowedTypes) {
                logger.Warn("Invalid content type",
                    zap.String("content_type", contentType),
                    zap.String("ip", c.ClientIP()),
                )
                c.AbortWithStatusJSON(http.StatusUnsupportedMediaType, gin.H{
                    "error": "Unsupported content type",
                })
                return
            }
        }

        // Basic request validation
        if err := validateRequest(c); err != nil {
            logger.Warn("Request validation failed",
                zap.Error(err),
                zap.String("ip", c.ClientIP()),
            )
            c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                "error": "Invalid request",
            })
            return
        }

        c.Next()
    })
}

func addSecurityHeaders(c *gin.Context, config SecurityConfig) {
    // X-Content-Type-Options
    c.Header("X-Content-Type-Options", "nosniff")

    // X-Frame-Options
    c.Header("X-Frame-Options", "DENY")

    // X-XSS-Protection
    c.Header("X-XSS-Protection", "1; mode=block")

    // Referrer Policy
    c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

    // Content Security Policy
    if config.CSPPolicy != "" {
        c.Header("Content-Security-Policy", config.CSPPolicy)
    }

    // HSTS
    if config.EnableHSTS {
        hstsValue := fmt.Sprintf("max-age=%d", config.HSTSMaxAge)
        if config.HSTSSubdomains {
            hstsValue += "; includeSubDomains"
        }
        c.Header("Strict-Transport-Security", hstsValue)
    }

    // Additional security headers
    c.Header("X-Permitted-Cross-Domain-Policies", "none")
    c.Header("X-Download-Options", "noopen")
    c.Header("X-DNS-Prefetch-Control", "off")
}

func handleCORS(c *gin.Context, config SecurityConfig) {
    origin := c.GetHeader("Origin")

    if isOriginAllowed(origin, config.AllowedOrigins) {
        c.Header("Access-Control-Allow-Origin", origin)

        if config.AllowCredentials {
            c.Header("Access-Control-Allow-Credentials", "true")
        }
    }
}

func isIPAllowed(ip string, config SecurityConfig) bool {
    // Check blocked IPs first
    for _, blockedIP := range config.BlockedIPs {
        if ip == blockedIP || isIPInRange(ip, blockedIP) {
            return false
        }
    }

    // If allowlist is configured, check it
    if len(config.AllowedIPs) > 0 {
        for _, allowedIP := range config.AllowedIPs {
            if ip == allowedIP || isIPInRange(ip, allowedIP) {
                return true
            }
        }
        return false // Not in allowlist
    }

    return true // No restrictions
}

func isOriginAllowed(origin string, allowedOrigins []string) bool {
    for _, allowed := range allowedOrigins {
        if allowed == "*" || allowed == origin {
            return true
        }

        // Check for wildcard subdomains
        if strings.HasPrefix(allowed, "*.") {
            domain := allowed[2:]
            if strings.HasSuffix(origin, domain) {
                return true
            }
        }
    }

    return false
}

func isContentTypeAllowed(contentType string, allowedTypes []string) bool {
    // Extract main content type (ignore charset, etc.)
    mainType := strings.Split(contentType, ";")[0]
    mainType = strings.TrimSpace(mainType)

    for _, allowed := range allowedTypes {
        if strings.EqualFold(mainType, allowed) {
            return true
        }
    }

    return false
}

func isIPInRange(ip, ipRange string) bool {
    // Simple CIDR check - in production, use proper CIDR library
    if strings.Contains(ipRange, "/") {
        // This is a simplified implementation
        // In production, use net.ParseCIDR and net.IP.Contains
        return false
    }

    return ip == ipRange
}

func validateRequest(c *gin.Context) error {
    // Check for suspicious patterns in headers
    userAgent := c.GetHeader("User-Agent")
    if containsSuspiciousPatterns(userAgent) {
        return fmt.Errorf("suspicious user agent")
    }

    // Check for SQL injection patterns in query parameters
    for key, values := range c.Request.URL.Query() {
        for _, value := range values {
            if containsSQLInjection(value) {
                return fmt.Errorf("potential SQL injection in parameter: %s", key)
            }
        }
    }

    return nil
}

func containsSuspiciousPatterns(input string) bool {
    suspiciousPatterns := []string{
        "sqlmap", "nikto", "nmap", "burp",
        "python-requests", "curl/", "wget/",
    }

    lowerInput := strings.ToLower(input)
    for _, pattern := range suspiciousPatterns {
        if strings.Contains(lowerInput, pattern) {
            return true
        }
    }

    return false
}

func containsSQLInjection(input string) bool {
    sqlPatterns := []string{
        "union select", "drop table", "insert into",
        "delete from", "update set", "'or'1'='1",
        "admin'--", "' or 1=1--", "'; drop table",
    }

    lowerInput := strings.ToLower(input)
    for _, pattern := range sqlPatterns {
        if strings.Contains(lowerInput, pattern) {
            return true
        }
    }

    return false
}
```

### 3. Configuration

```yaml
# config/security.yaml
security:
  rate_limiting:
    global_rps: 1000
    global_burst: 100
    user_rpm: 300
    user_burst: 50
    ip_rpm: 60
    ip_burst: 10
    window_size: "1m"
    cleanup_interval: "5m"
    block_duration: "15m"
    suspicious_threshold: 10

    endpoint_limits:
      "POST:/auth/login":
        rpm: 10
        burst: 2
      "POST:/auth/register":
        rpm: 5
        burst: 1
      "POST:/journals":
        user_rpm: 60
        user_burst: 10
        rpm: 10
        burst: 2
      "GET:/journals":
        user_rpm: 120
        user_burst: 20
        rpm: 30
        burst: 5

  cors:
    allowed_origins:
      - "http://localhost:3000"
      - "https://englog.com"
      - "https://*.englog.com"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "OPTIONS"
    allowed_headers:
      - "Authorization"
      - "Content-Type"
      - "X-Requested-With"
    allow_credentials: true
    max_age: 86400

  headers:
    enable_hsts: true
    hsts_max_age: 31536000
    hsts_subdomains: true
    csp_policy: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"

  request_limits:
    max_request_size: 10485760 # 10MB
    max_header_size: 32768 # 32KB

  ip_filtering:
    blocked_ips: []
    allowed_ips: []
    blocked_countries: []
```

### 4. Middleware Integration

```go
// cmd/api/main.go (integration example)
func setupMiddleware(router *gin.Engine, deps *Dependencies) {
    // Security middleware (first)
    router.Use(middleware.SecurityMiddleware(deps.Config.Security, deps.Logger))
    router.Use(middleware.CORSMiddleware(deps.Config.Security))
    router.Use(middleware.ContentValidationMiddleware(deps.Logger))

    // Rate limiting middleware
    rateLimiter := middleware.NewRateLimiter(
        deps.Redis,
        deps.Logger,
        deps.Config.Security.RateLimiting,
    )
    router.Use(rateLimiter.Middleware())

    // Other middleware
    router.Use(middleware.LoggingMiddleware(deps.Logger))
    router.Use(middleware.RecoveryMiddleware(deps.Logger))

    // Authentication middleware (for protected routes)
    authRouter := router.Group("/api/v1")
    authRouter.Use(middleware.AuthMiddleware(deps.Auth))
}
```

## Testing Strategy

### Unit Tests

```go
// middleware/rate_limiter_test.go
func TestRateLimiter(t *testing.T) {
    redis := setupTestRedis(t)
    logger := zap.NewNop()

    config := RateLimitConfig{
        GlobalRPS: 10,
        GlobalBurst: 5,
        UserRPM: 60,
        UserBurst: 10,
        WindowSize: time.Minute,
    }

    rl := NewRateLimiter(redis, logger, config)

    t.Run("allows requests within limit", func(t *testing.T) {
        result := rl.checkSlidingWindow("test:key", 10, 5, time.Minute)
        assert.True(t, result.Allowed)
        assert.Equal(t, 15, result.Limit)
        assert.Equal(t, 14, result.Remaining)
    })

    t.Run("blocks requests exceeding limit", func(t *testing.T) {
        key := "test:limit"

        // Fill up the limit
        for i := 0; i < 15; i++ {
            rl.checkSlidingWindow(key, 10, 5, time.Minute)
        }

        // Next request should be blocked
        result := rl.checkSlidingWindow(key, 10, 5, time.Minute)
        assert.False(t, result.Allowed)
        assert.Equal(t, 0, result.Remaining)
    })
}

func TestSecurityMiddleware(t *testing.T) {
    config := SecurityConfig{
        AllowedOrigins: []string{"https://example.com"},
        BlockedIPs: []string{"192.168.1.100"},
        MaxRequestSize: 1024,
    }

    t.Run("blocks requests from blocked IPs", func(t *testing.T) {
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        c.Request = httptest.NewRequest("GET", "/", nil)
        c.Request.RemoteAddr = "192.168.1.100:12345"

        middleware := SecurityMiddleware(config, zap.NewNop())
        middleware(c)

        assert.Equal(t, http.StatusForbidden, w.Code)
    })

    t.Run("adds security headers", func(t *testing.T) {
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        c.Request = httptest.NewRequest("GET", "/", nil)

        middleware := SecurityMiddleware(config, zap.NewNop())
        middleware(c)

        assert.Equal(t, "nosniff", w.Header().Get("X-Content-Type-Options"))
        assert.Equal(t, "DENY", w.Header().Get("X-Frame-Options"))
    })
}
```

### Integration Tests

```go
// Test rate limiting with real Redis
func TestRateLimitingIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    redis := setupIntegrationRedis(t)
    server := setupTestServer(t, redis)

    // Test global rate limit
    for i := 0; i < 100; i++ {
        resp, err := http.Get(server.URL + "/api/health")
        require.NoError(t, err)
        resp.Body.Close()

        if i > 50 && resp.StatusCode == 429 {
            // Rate limit should kick in
            assert.Equal(t, "application/json", resp.Header.Get("Content-Type"))
            break
        }
    }
}
```

## Acceptance Criteria

### Rate Limiting

- [ ] Global rate limits protect against DDoS attacks
- [ ] Per-user rate limits prevent individual abuse
- [ ] Per-IP rate limits protect unauthenticated endpoints
- [ ] Endpoint-specific limits protect sensitive operations
- [ ] Rate limit headers included in all responses

### Security Headers

- [ ] All security headers properly configured
- [ ] CORS policy prevents unauthorized origins
- [ ] CSP policy prevents XSS attacks
- [ ] HSTS enables secure connections

### Request Validation

- [ ] Request size limits prevent oversized requests
- [ ] Content type validation blocks invalid requests
- [ ] SQL injection detection blocks malicious input
- [ ] Suspicious user agents logged and monitored

### Performance

- [ ] Middleware adds < 5ms latency per request
- [ ] Redis operations complete within 2ms
- [ ] Memory usage remains stable under load
- [ ] Cleanup routines prevent memory leaks

### Monitoring

- [ ] Rate limit violations logged with context
- [ ] Security events tracked for analysis
- [ ] Performance metrics exposed to monitoring
- [ ] Alert rules configured for security events

## Success Metrics

- 99.9% of legitimate requests processed successfully
- < 5ms average middleware latency
- 0 successful attacks in security testing
- Rate limiting blocks 95%+ of abuse attempts
- Security headers score A+ on security scanners
