# MVP-018: API Documentation & OpenAPI Specification

**Feature Area:** MVP-API (API Layer)
**Priority:** P1 (High)
**Effort:** Medium (2 days)
**Dependencies:** MVP-017 (Rate Limiting & Security Middleware)

## Overview

Create comprehensive API documentation using OpenAPI 3.0 specification with automated generation from code annotations. This includes interactive documentation, request/response examples, authentication flows, and error handling documentation to enable easy integration and developer adoption.

## Business Context

Comprehensive API documentation is critical for developer adoption, reducing support burden, and enabling third-party integrations. Interactive documentation reduces the learning curve and accelerates development for both internal teams and potential API consumers.

## Requirements

### Functional Requirements

1. **OpenAPI Specification**

   - Complete OpenAPI 3.0 specification
   - Automated generation from code annotations
   - Request/response schemas with examples
   - Authentication and security documentation

2. **Interactive Documentation**

   - Swagger UI integration
   - Live API testing interface
   - Code generation examples
   - Authentication testing support

3. **API Reference**

   - Endpoint descriptions and parameters
   - Response status codes and schemas
   - Error handling documentation
   - Rate limiting information

4. **Developer Guides**
   - Getting started guide
   - Authentication flow examples
   - Common use case tutorials
   - SDK and client library information

### Technical Requirements

1. **Documentation Generation**

   - Automated from code annotations
   - CI/CD integration for updates
   - Version management and history
   - Multiple output formats

2. **Interactive Features**

   - Live API testing
   - Request/response validation
   - Authentication configuration
   - Environment switching

3. **Accessibility**

   - Public documentation hosting
   - Mobile-responsive design
   - Search functionality
   - Offline documentation support

4. **Integration**
   - Embedded in application
   - External hosting options
   - API client generation
   - Postman collection export

## Implementation

### 1. OpenAPI Specification Generation

```go
// internal/docs/openapi.go
package docs

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/swaggo/files"
    "github.com/swaggo/gin-swagger"
    "github.com/swaggo/swag"
)

// APIInfo contains the OpenAPI specification info
type APIInfo struct {
    Title         string `json:"title"`
    Description   string `json:"description"`
    Version       string `json:"version"`
    TermsOfService string `json:"termsOfService,omitempty"`
    Contact       Contact `json:"contact,omitempty"`
    License       License `json:"license,omitempty"`
}

type Contact struct {
    Name  string `json:"name,omitempty"`
    URL   string `json:"url,omitempty"`
    Email string `json:"email,omitempty"`
}

type License struct {
    Name string `json:"name"`
    URL  string `json:"url,omitempty"`
}

// OpenAPISpec represents the complete OpenAPI specification
type OpenAPISpec struct {
    OpenAPI    string                 `json:"openapi"`
    Info       APIInfo                `json:"info"`
    Servers    []Server               `json:"servers"`
    Paths      map[string]Path        `json:"paths"`
    Components Components             `json:"components"`
    Security   []map[string][]string  `json:"security,omitempty"`
    Tags       []Tag                  `json:"tags,omitempty"`
}

type Server struct {
    URL         string                    `json:"url"`
    Description string                    `json:"description,omitempty"`
    Variables   map[string]ServerVariable `json:"variables,omitempty"`
}

type ServerVariable struct {
    Enum        []string `json:"enum,omitempty"`
    Default     string   `json:"default"`
    Description string   `json:"description,omitempty"`
}

type Path struct {
    GET    *Operation `json:"get,omitempty"`
    POST   *Operation `json:"post,omitempty"`
    PUT    *Operation `json:"put,omitempty"`
    DELETE *Operation `json:"delete,omitempty"`
    PATCH  *Operation `json:"patch,omitempty"`
}

type Operation struct {
    Tags        []string              `json:"tags,omitempty"`
    Summary     string                `json:"summary,omitempty"`
    Description string                `json:"description,omitempty"`
    OperationID string                `json:"operationId,omitempty"`
    Parameters  []Parameter           `json:"parameters,omitempty"`
    RequestBody *RequestBody          `json:"requestBody,omitempty"`
    Responses   map[string]Response   `json:"responses"`
    Security    []map[string][]string `json:"security,omitempty"`
}

type Parameter struct {
    Name        string      `json:"name"`
    In          string      `json:"in"`
    Description string      `json:"description,omitempty"`
    Required    bool        `json:"required,omitempty"`
    Schema      Schema      `json:"schema"`
    Example     interface{} `json:"example,omitempty"`
}

type RequestBody struct {
    Description string                `json:"description,omitempty"`
    Content     map[string]MediaType  `json:"content"`
    Required    bool                  `json:"required,omitempty"`
}

type Response struct {
    Description string               `json:"description"`
    Headers     map[string]Header    `json:"headers,omitempty"`
    Content     map[string]MediaType `json:"content,omitempty"`
}

type MediaType struct {
    Schema   Schema                 `json:"schema,omitempty"`
    Example  interface{}            `json:"example,omitempty"`
    Examples map[string]Example     `json:"examples,omitempty"`
}

type Schema struct {
    Type        string            `json:"type,omitempty"`
    Format      string            `json:"format,omitempty"`
    Items       *Schema           `json:"items,omitempty"`
    Properties  map[string]Schema `json:"properties,omitempty"`
    Required    []string          `json:"required,omitempty"`
    Example     interface{}       `json:"example,omitempty"`
    Description string            `json:"description,omitempty"`
    Ref         string            `json:"$ref,omitempty"`
}

type Header struct {
    Description string  `json:"description,omitempty"`
    Schema      Schema  `json:"schema"`
}

type Example struct {
    Summary     string      `json:"summary,omitempty"`
    Description string      `json:"description,omitempty"`
    Value       interface{} `json:"value"`
}

type Components struct {
    Schemas         map[string]Schema         `json:"schemas,omitempty"`
    Responses       map[string]Response       `json:"responses,omitempty"`
    Parameters      map[string]Parameter      `json:"parameters,omitempty"`
    Examples        map[string]Example        `json:"examples,omitempty"`
    RequestBodies   map[string]RequestBody    `json:"requestBodies,omitempty"`
    Headers         map[string]Header         `json:"headers,omitempty"`
    SecuritySchemes map[string]SecurityScheme `json:"securitySchemes,omitempty"`
}

type SecurityScheme struct {
    Type         string      `json:"type"`
    Description  string      `json:"description,omitempty"`
    Name         string      `json:"name,omitempty"`
    In           string      `json:"in,omitempty"`
    Scheme       string      `json:"scheme,omitempty"`
    BearerFormat string      `json:"bearerFormat,omitempty"`
    Flows        *OAuthFlows `json:"flows,omitempty"`
}

type OAuthFlows struct {
    Implicit          *OAuthFlow `json:"implicit,omitempty"`
    Password          *OAuthFlow `json:"password,omitempty"`
    ClientCredentials *OAuthFlow `json:"clientCredentials,omitempty"`
    AuthorizationCode *OAuthFlow `json:"authorizationCode,omitempty"`
}

type OAuthFlow struct {
    AuthorizationURL string            `json:"authorizationUrl,omitempty"`
    TokenURL         string            `json:"tokenUrl,omitempty"`
    RefreshURL       string            `json:"refreshUrl,omitempty"`
    Scopes           map[string]string `json:"scopes"`
}

type Tag struct {
    Name         string        `json:"name"`
    Description  string        `json:"description,omitempty"`
    ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`
}

type ExternalDocs struct {
    Description string `json:"description,omitempty"`
    URL         string `json:"url"`
}

// GenerateSpec creates the complete OpenAPI specification
func GenerateSpec() *OpenAPISpec {
    return &OpenAPISpec{
        OpenAPI: "3.0.3",
        Info: APIInfo{
            Title:       "EngLog API",
            Description: "Personal journal management system with AI-powered insights",
            Version:     "1.0.0",
            Contact: Contact{
                Name:  "EngLog Team",
                Email: "api@englog.com",
                URL:   "https://englog.com/support",
            },
            License: License{
                Name: "MIT",
                URL:  "https://opensource.org/licenses/MIT",
            },
        },
        Servers: []Server{
            {
                URL:         "https://api.englog.com/v1",
                Description: "Production server",
            },
            {
                URL:         "https://staging-api.englog.com/v1",
                Description: "Staging server",
            },
            {
                URL:         "http://localhost:8080/v1",
                Description: "Development server",
            },
        },
        Paths:      generatePaths(),
        Components: generateComponents(),
        Security: []map[string][]string{
            {"bearerAuth": {}},
        },
        Tags: []Tag{
            {
                Name:        "Authentication",
                Description: "User authentication and authorization endpoints",
            },
            {
                Name:        "Journals",
                Description: "Journal entry management operations",
            },
            {
                Name:        "Users",
                Description: "User profile and preferences management",
            },
            {
                Name:        "AI Processing",
                Description: "AI-powered analysis and insights",
            },
            {
                Name:        "Health",
                Description: "System health and monitoring endpoints",
            },
        },
    }
}

func generatePaths() map[string]Path {
    return map[string]Path{
        "/health": {
            GET: &Operation{
                Tags:        []string{"Health"},
                Summary:     "Health check",
                Description: "Returns the health status of the API service",
                OperationID: "healthCheck",
                Responses: map[string]Response{
                    "200": {
                        Description: "Service is healthy",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/HealthResponse",
                                },
                            },
                        },
                    },
                },
                Security: []map[string][]string{}, // No auth required
            },
        },
        "/auth/login": {
            POST: &Operation{
                Tags:        []string{"Authentication"},
                Summary:     "User login",
                Description: "Authenticate user with email and password or initiate OAuth flow",
                OperationID: "login",
                RequestBody: &RequestBody{
                    Description: "Login credentials",
                    Required:    true,
                    Content: map[string]MediaType{
                        "application/json": {
                            Schema: Schema{
                                Ref: "#/components/schemas/LoginRequest",
                            },
                        },
                    },
                },
                Responses: map[string]Response{
                    "200": {
                        Description: "Login successful",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/AuthResponse",
                                },
                            },
                        },
                    },
                    "400": {
                        Description: "Invalid request",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                    "401": {
                        Description: "Invalid credentials",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                    "429": {
                        Description: "Rate limit exceeded",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/RateLimitResponse",
                                },
                            },
                        },
                    },
                },
                Security: []map[string][]string{}, // No auth required
            },
        },
        "/journals": {
            GET: &Operation{
                Tags:        []string{"Journals"},
                Summary:     "List user journals",
                Description: "Retrieve a paginated list of journal entries for the authenticated user",
                OperationID: "listJournals",
                Parameters: []Parameter{
                    {
                        Name:        "limit",
                        In:          "query",
                        Description: "Number of journal entries to return (default: 20, max: 100)",
                        Schema: Schema{
                            Type:    "integer",
                            Format:  "int32",
                            Example: 20,
                        },
                    },
                    {
                        Name:        "offset",
                        In:          "query",
                        Description: "Number of journal entries to skip for pagination",
                        Schema: Schema{
                            Type:    "integer",
                            Format:  "int32",
                            Example: 0,
                        },
                    },
                    {
                        Name:        "search",
                        In:          "query",
                        Description: "Search term to filter journal entries",
                        Schema: Schema{
                            Type:    "string",
                            Example: "productivity",
                        },
                    },
                },
                Responses: map[string]Response{
                    "200": {
                        Description: "List of journal entries",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/JournalListResponse",
                                },
                            },
                        },
                    },
                    "401": {
                        Description: "Unauthorized",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                },
            },
            POST: &Operation{
                Tags:        []string{"Journals"},
                Summary:     "Create journal entry",
                Description: "Create a new journal entry with flexible content structure",
                OperationID: "createJournal",
                RequestBody: &RequestBody{
                    Description: "Journal entry data",
                    Required:    true,
                    Content: map[string]MediaType{
                        "application/json": {
                            Schema: Schema{
                                Ref: "#/components/schemas/CreateJournalRequest",
                            },
                        },
                    },
                },
                Responses: map[string]Response{
                    "201": {
                        Description: "Journal entry created successfully",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/JournalResponse",
                                },
                            },
                        },
                    },
                    "400": {
                        Description: "Invalid request data",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ValidationErrorResponse",
                                },
                            },
                        },
                    },
                    "401": {
                        Description: "Unauthorized",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                },
            },
        },
        "/journals/{id}": {
            GET: &Operation{
                Tags:        []string{"Journals"},
                Summary:     "Get journal entry",
                Description: "Retrieve a specific journal entry by ID",
                OperationID: "getJournal",
                Parameters: []Parameter{
                    {
                        Name:        "id",
                        In:          "path",
                        Description: "Journal entry ID",
                        Required:    true,
                        Schema: Schema{
                            Type:   "string",
                            Format: "uuid",
                        },
                    },
                },
                Responses: map[string]Response{
                    "200": {
                        Description: "Journal entry details",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/JournalResponse",
                                },
                            },
                        },
                    },
                    "404": {
                        Description: "Journal entry not found",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                },
            },
            PUT: &Operation{
                Tags:        []string{"Journals"},
                Summary:     "Update journal entry",
                Description: "Update an existing journal entry",
                OperationID: "updateJournal",
                Parameters: []Parameter{
                    {
                        Name:        "id",
                        In:          "path",
                        Description: "Journal entry ID",
                        Required:    true,
                        Schema: Schema{
                            Type:   "string",
                            Format: "uuid",
                        },
                    },
                },
                RequestBody: &RequestBody{
                    Description: "Updated journal entry data",
                    Required:    true,
                    Content: map[string]MediaType{
                        "application/json": {
                            Schema: Schema{
                                Ref: "#/components/schemas/UpdateJournalRequest",
                            },
                        },
                    },
                },
                Responses: map[string]Response{
                    "200": {
                        Description: "Journal entry updated successfully",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/JournalResponse",
                                },
                            },
                        },
                    },
                    "400": {
                        Description: "Invalid request data",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ValidationErrorResponse",
                                },
                            },
                        },
                    },
                    "404": {
                        Description: "Journal entry not found",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                },
            },
            DELETE: &Operation{
                Tags:        []string{"Journals"},
                Summary:     "Delete journal entry",
                Description: "Delete a journal entry permanently",
                OperationID: "deleteJournal",
                Parameters: []Parameter{
                    {
                        Name:        "id",
                        In:          "path",
                        Description: "Journal entry ID",
                        Required:    true,
                        Schema: Schema{
                            Type:   "string",
                            Format: "uuid",
                        },
                    },
                },
                Responses: map[string]Response{
                    "204": {
                        Description: "Journal entry deleted successfully",
                    },
                    "404": {
                        Description: "Journal entry not found",
                        Content: map[string]MediaType{
                            "application/json": {
                                Schema: Schema{
                                    Ref: "#/components/schemas/ErrorResponse",
                                },
                            },
                        },
                    },
                },
            },
        },
    }
}

func generateComponents() Components {
    return Components{
        SecuritySchemes: map[string]SecurityScheme{
            "bearerAuth": {
                Type:         "http",
                Scheme:       "bearer",
                BearerFormat: "JWT",
                Description:  "JWT token-based authentication",
            },
        },
        Schemas: map[string]Schema{
            "HealthResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "status": {
                        Type:        "string",
                        Example:     "healthy",
                        Description: "Service health status",
                    },
                    "timestamp": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "Health check timestamp",
                    },
                    "version": {
                        Type:        "string",
                        Example:     "1.0.0",
                        Description: "API version",
                    },
                },
                Required: []string{"status", "timestamp", "version"},
            },
            "LoginRequest": {
                Type: "object",
                Properties: map[string]Schema{
                    "email": {
                        Type:        "string",
                        Format:      "email",
                        Example:     "user@example.com",
                        Description: "User email address",
                    },
                    "password": {
                        Type:        "string",
                        Format:      "password",
                        Example:     "securepassword123",
                        Description: "User password",
                    },
                    "provider": {
                        Type:        "string",
                        Example:     "google",
                        Description: "OAuth provider (google, github, microsoft)",
                    },
                },
            },
            "AuthResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "access_token": {
                        Type:        "string",
                        Description: "JWT access token",
                    },
                    "refresh_token": {
                        Type:        "string",
                        Description: "JWT refresh token",
                    },
                    "token_type": {
                        Type:        "string",
                        Example:     "Bearer",
                        Description: "Token type",
                    },
                    "expires_in": {
                        Type:        "integer",
                        Example:     3600,
                        Description: "Token expiration time in seconds",
                    },
                    "user": {
                        Ref: "#/components/schemas/User",
                    },
                },
                Required: []string{"access_token", "token_type", "expires_in", "user"},
            },
            "User": {
                Type: "object",
                Properties: map[string]Schema{
                    "id": {
                        Type:        "string",
                        Format:      "uuid",
                        Description: "User unique identifier",
                    },
                    "email": {
                        Type:        "string",
                        Format:      "email",
                        Description: "User email address",
                    },
                    "name": {
                        Type:        "string",
                        Description: "User display name",
                    },
                    "created_at": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "User creation timestamp",
                    },
                },
                Required: []string{"id", "email", "name", "created_at"},
            },
            "CreateJournalRequest": {
                Type: "object",
                Properties: map[string]Schema{
                    "raw_data": {
                        Type:        "object",
                        Description: "Flexible journal content - accepts any JSON structure",
                        Example: map[string]interface{}{
                            "content": "Today was a productive day. I finished the project proposal and had a great team meeting.",
                            "mood": 8,
                            "tags": []string{"work", "productivity", "team"},
                            "location": map[string]interface{}{
                                "name": "Office",
                                "lat":  40.7128,
                                "lng":  -74.0060,
                            },
                        },
                    },
                    "entry_type": {
                        Type:        "string",
                        Example:     "text",
                        Description: "Type of journal entry (text, voice, photo, mixed)",
                    },
                },
                Required: []string{"raw_data"},
            },
            "JournalResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "id": {
                        Type:        "string",
                        Format:      "uuid",
                        Description: "Journal entry unique identifier",
                    },
                    "user_id": {
                        Type:        "string",
                        Format:      "uuid",
                        Description: "Owner user ID",
                    },
                    "raw_data": {
                        Type:        "object",
                        Description: "Journal content data",
                    },
                    "entry_type": {
                        Type:        "string",
                        Description: "Type of journal entry",
                    },
                    "processing_status": {
                        Type:        "string",
                        Example:     "completed",
                        Description: "AI processing status (pending, processing, completed, failed)",
                    },
                    "created_at": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "Entry creation timestamp",
                    },
                    "updated_at": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "Last update timestamp",
                    },
                },
                Required: []string{"id", "user_id", "raw_data", "entry_type", "created_at"},
            },
            "JournalListResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "journals": {
                        Type: "array",
                        Items: &Schema{
                            Ref: "#/components/schemas/JournalResponse",
                        },
                    },
                    "pagination": {
                        Ref: "#/components/schemas/PaginationInfo",
                    },
                },
                Required: []string{"journals", "pagination"},
            },
            "PaginationInfo": {
                Type: "object",
                Properties: map[string]Schema{
                    "total": {
                        Type:        "integer",
                        Description: "Total number of items",
                    },
                    "limit": {
                        Type:        "integer",
                        Description: "Number of items per page",
                    },
                    "offset": {
                        Type:        "integer",
                        Description: "Number of items skipped",
                    },
                    "has_next": {
                        Type:        "boolean",
                        Description: "Whether there are more items available",
                    },
                },
                Required: []string{"total", "limit", "offset", "has_next"},
            },
            "ErrorResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "error": {
                        Type:        "string",
                        Description: "Error message",
                    },
                    "code": {
                        Type:        "string",
                        Description: "Error code",
                    },
                    "timestamp": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "Error timestamp",
                    },
                    "request_id": {
                        Type:        "string",
                        Description: "Request ID for debugging",
                    },
                },
                Required: []string{"error", "timestamp"},
            },
            "ValidationErrorResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "error": {
                        Type:        "string",
                        Description: "Validation error message",
                    },
                    "validation_errors": {
                        Type: "array",
                        Items: &Schema{
                            Ref: "#/components/schemas/FieldError",
                        },
                    },
                    "timestamp": {
                        Type:        "string",
                        Format:      "date-time",
                        Description: "Error timestamp",
                    },
                },
                Required: []string{"error", "validation_errors", "timestamp"},
            },
            "FieldError": {
                Type: "object",
                Properties: map[string]Schema{
                    "field": {
                        Type:        "string",
                        Description: "Field name with validation error",
                    },
                    "message": {
                        Type:        "string",
                        Description: "Validation error message",
                    },
                    "code": {
                        Type:        "string",
                        Description: "Validation error code",
                    },
                },
                Required: []string{"field", "message"},
            },
            "RateLimitResponse": {
                Type: "object",
                Properties: map[string]Schema{
                    "error": {
                        Type:        "string",
                        Example:     "Rate limit exceeded",
                        Description: "Rate limit error message",
                    },
                    "retry_after": {
                        Type:        "integer",
                        Description: "Seconds to wait before retrying",
                    },
                    "limit": {
                        Type:        "integer",
                        Description: "Rate limit threshold",
                    },
                },
                Required: []string{"error", "retry_after", "limit"},
            },
        },
    }
}

// SetupDocumentation configures API documentation routes
func SetupDocumentation(router *gin.Engine, spec *OpenAPISpec) {
    // Serve OpenAPI JSON specification
    router.GET("/api/openapi.json", func(c *gin.Context) {
        c.JSON(http.StatusOK, spec)
    })

    // Serve Swagger UI
    router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

    // Serve documentation landing page
    router.GET("/docs", func(c *gin.Context) {
        c.Redirect(http.StatusMovedPermanently, "/docs/index.html")
    })

    // Health check for documentation
    router.GET("/docs/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "healthy",
            "docs_version": spec.Info.Version,
            "swagger_ui": "available",
        })
    })
}
```

### 2. Code Annotation System

```go
// internal/handlers/journal.go (with annotations)
package handlers

// @Summary Create journal entry
// @Description Create a new journal entry with flexible content structure
// @Tags Journals
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer token"
// @Param journal body models.CreateJournalRequest true "Journal entry data"
// @Success 201 {object} models.JournalResponse "Journal entry created successfully"
// @Failure 400 {object} models.ValidationErrorResponse "Invalid request data"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /journals [post]
func (h *JournalHandler) CreateJournal(c *gin.Context) {
    // Implementation here
}

// @Summary List user journals
// @Description Retrieve a paginated list of journal entries for the authenticated user
// @Tags Journals
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer token"
// @Param limit query int false "Number of entries to return (default: 20, max: 100)"
// @Param offset query int false "Number of entries to skip"
// @Param search query string false "Search term to filter entries"
// @Success 200 {object} models.JournalListResponse "List of journal entries"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /journals [get]
func (h *JournalHandler) ListJournals(c *gin.Context) {
    // Implementation here
}

// @Summary Get journal entry
// @Description Retrieve a specific journal entry by ID
// @Tags Journals
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer token"
// @Param id path string true "Journal entry ID" format(uuid)
// @Success 200 {object} models.JournalResponse "Journal entry details"
// @Failure 404 {object} models.ErrorResponse "Journal entry not found"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Router /journals/{id} [get]
func (h *JournalHandler) GetJournal(c *gin.Context) {
    // Implementation here
}
```

### 3. Interactive Documentation Setup

```html
<!-- docs/swagger-ui.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>EngLog API Documentation</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css"
    />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <style>
      html {
        box-sizing: border-box;
        overflow: -moz-scrollbars-vertical;
        overflow-y: scroll;
      }
      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }
      body {
        margin: 0;
        background: #fafafa;
      }
      .swagger-ui .topbar {
        background-color: #4f46e5;
      }
      .swagger-ui .topbar .download-url-wrapper .select-label {
        color: white;
      }
      .custom-header {
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        color: white;
        padding: 20px;
        text-align: center;
      }
      .custom-header h1 {
        margin: 0;
        font-size: 2.5em;
        font-weight: 300;
      }
      .custom-header p {
        margin: 10px 0 0 0;
        font-size: 1.2em;
        opacity: 0.9;
      }
      .api-info {
        background: white;
        padding: 20px;
        border-bottom: 1px solid #eee;
      }
      .api-info .info-section {
        display: inline-block;
        margin: 0 30px 20px 0;
        vertical-align: top;
      }
      .api-info .info-section h3 {
        margin: 0 0 10px 0;
        color: #4f46e5;
        font-size: 1.1em;
      }
      .api-info .info-section ul {
        margin: 0;
        padding-left: 20px;
      }
      .api-info .info-section li {
        margin-bottom: 5px;
      }
      .quick-start {
        background: #f8fafc;
        padding: 20px;
        border-left: 4px solid #4f46e5;
        margin: 20px;
        border-radius: 0 8px 8px 0;
      }
      .quick-start h3 {
        margin: 0 0 15px 0;
        color: #4f46e5;
      }
      .quick-start code {
        background: #1f2937;
        color: #f9fafb;
        padding: 15px;
        border-radius: 6px;
        display: block;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 14px;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <div class="custom-header">
      <h1>EngLog API</h1>
      <p>Personal journal management with AI-powered insights</p>
    </div>

    <div class="api-info">
      <div class="info-section">
        <h3>üöÄ Getting Started</h3>
        <ul>
          <li>Sign up for an account</li>
          <li>Get your API key from settings</li>
          <li>Start making requests</li>
        </ul>
      </div>

      <div class="info-section">
        <h3>üìö Key Features</h3>
        <ul>
          <li>Flexible journal data structure</li>
          <li>AI-powered sentiment analysis</li>
          <li>Real-time processing status</li>
          <li>RESTful API design</li>
        </ul>
      </div>

      <div class="info-section">
        <h3>üîí Authentication</h3>
        <ul>
          <li>JWT token-based auth</li>
          <li>OAuth 2.0 support</li>
          <li>Rate limiting protection</li>
          <li>Secure by default</li>
        </ul>
      </div>

      <div class="info-section">
        <h3>üí¨ Support</h3>
        <ul>
          <li><a href="mailto:api@englog.com">Email Support</a></li>
          <li><a href="https://github.com/englog/api">GitHub Issues</a></li>
          <li><a href="https://discord.gg/englog">Discord Community</a></li>
        </ul>
      </div>
    </div>

    <div class="quick-start">
      <h3>Quick Start Example</h3>
      <code>
        # Authenticate and get token curl -X POST
        https://api.englog.com/v1/auth/login \ -H "Content-Type:
        application/json" \ -d '{"email": "user@example.com", "password":
        "your-password"}' # Create a journal entry curl -X POST
        https://api.englog.com/v1/journals \ -H "Authorization: Bearer
        YOUR_TOKEN" \ -H "Content-Type: application/json" \ -d '{ "raw_data": {
        "content": "Today was a great day!", "mood": 8, "tags": ["personal",
        "positive"] } }'
      </code>
    </div>

    <div id="swagger-ui"></div>

    <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"></script>
    <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js"></script>
    <script>
      window.onload = function () {
        const ui = SwaggerUIBundle({
          url: "/api/openapi.json",
          dom_id: "#swagger-ui",
          deepLinking: true,
          presets: [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset],
          plugins: [SwaggerUIBundle.plugins.DownloadUrl],
          layout: "StandaloneLayout",
          tryItOutEnabled: true,
          requestInterceptor: function (request) {
            // Add custom headers or modify requests
            request.headers["X-Requested-With"] = "swagger-ui";
            return request;
          },
          responseInterceptor: function (response) {
            // Log responses for debugging
            console.log("API Response:", response);
            return response;
          },
          onComplete: function () {
            console.log("Swagger UI loaded successfully");
          },
          validatorUrl: null,
          docExpansion: "list",
          defaultModelExpandDepth: 3,
          defaultModelsExpandDepth: 1,
          displayRequestDuration: true,
          filter: true,
          showExtensions: true,
          showCommonExtensions: true,
          persistAuthorization: true,
        });

        // Custom authentication helper
        window.swaggerUi = ui;

        // Add authentication button
        setTimeout(function () {
          const authButton = document.createElement("button");
          authButton.innerHTML = "üîê Test Authentication";
          authButton.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #4f46e5;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 6px;
                    cursor: pointer;
                    z-index: 1000;
                    font-weight: 600;
                `;

          authButton.onclick = function () {
            const token = prompt("Enter your JWT token:");
            if (token) {
              ui.preauthorizeApiKey("bearerAuth", "Bearer " + token);
              alert(
                "Token configured! You can now test authenticated endpoints."
              );
            }
          };

          document.body.appendChild(authButton);
        }, 1000);
      };
    </script>
  </body>
</html>
```

### 4. Documentation Generation Script

```bash
#!/bin/bash
# scripts/generate-docs.sh

set -e

echo "üîÑ Generating API documentation..."

# Generate OpenAPI spec from code annotations
echo "üìù Generating OpenAPI specification..."
swag init -g cmd/api/main.go -o docs/swagger --parseInternal

# Validate OpenAPI spec
echo "‚úÖ Validating OpenAPI specification..."
swagger-codegen validate -i docs/swagger/swagger.json

# Generate client libraries
echo "üìö Generating client libraries..."

# Generate Go client
swagger-codegen generate \
  -i docs/swagger/swagger.json \
  -l go \
  -o clients/go \
  --additional-properties packageName=englog

# Generate JavaScript client
swagger-codegen generate \
  -i docs/swagger/swagger.json \
  -l javascript \
  -o clients/javascript \
  --additional-properties projectName=englog-api-client

# Generate Python client
swagger-codegen generate \
  -i docs/swagger/swagger.json \
  -l python \
  -o clients/python \
  --additional-properties packageName=englog_api

# Generate Postman collection
echo "üìÆ Generating Postman collection..."
openapi2postman \
  -s docs/swagger/swagger.json \
  -o docs/postman/englog-api.json \
  --pretty

# Generate markdown documentation
echo "üìñ Generating markdown documentation..."
swagger-codegen generate \
  -i docs/swagger/swagger.json \
  -l dynamic-html \
  -o docs/html

echo "‚úÖ Documentation generation complete!"
echo "üìÇ Files generated in:"
echo "  - docs/swagger/swagger.json"
echo "  - docs/html/"
echo "  - clients/"
echo "  - docs/postman/"
```

### 5. CI/CD Integration

```yaml
# .github/workflows/docs.yml
name: Documentation

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  generate-docs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"

      - name: Install swagger
        run: |
          go install github.com/swaggo/swag/cmd/swag@latest
          npm install -g swagger-codegen-cli
          npm install -g openapi-to-postman

      - name: Generate documentation
        run: ./scripts/generate-docs.sh

      - name: Validate OpenAPI spec
        run: |
          swagger-codegen validate -i docs/swagger/swagger.json

      - name: Deploy to GitHub Pages (main only)
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/html
          destination_dir: api-docs

      - name: Upload documentation artifacts
        uses: actions/upload-artifact@v3
        with:
          name: api-documentation
          path: |
            docs/swagger/
            docs/html/
            docs/postman/
            clients/
```

## Testing Strategy

### Documentation Tests

```go
// test/docs_test.go
func TestOpenAPISpecification(t *testing.T) {
    spec := docs.GenerateSpec()

    t.Run("validates OpenAPI version", func(t *testing.T) {
        assert.Equal(t, "3.0.3", spec.OpenAPI)
    })

    t.Run("includes required paths", func(t *testing.T) {
        requiredPaths := []string{
            "/health",
            "/auth/login",
            "/journals",
            "/journals/{id}",
        }

        for _, path := range requiredPaths {
            assert.Contains(t, spec.Paths, path)
        }
    })

    t.Run("includes security schemes", func(t *testing.T) {
        assert.Contains(t, spec.Components.SecuritySchemes, "bearerAuth")
        bearerAuth := spec.Components.SecuritySchemes["bearerAuth"]
        assert.Equal(t, "http", bearerAuth.Type)
        assert.Equal(t, "bearer", bearerAuth.Scheme)
    })

    t.Run("validates schema references", func(t *testing.T) {
        // Check that all $ref references exist
        for pathName, path := range spec.Paths {
            operations := []*docs.Operation{
                path.GET, path.POST, path.PUT, path.DELETE,
            }

            for _, op := range operations {
                if op == nil {
                    continue
                }

                // Check response schemas
                for _, response := range op.Responses {
                    if response.Content != nil {
                        for _, mediaType := range response.Content {
                            if mediaType.Schema.Ref != "" {
                                assert.True(t, strings.HasPrefix(mediaType.Schema.Ref, "#/components/schemas/"))
                            }
                        }
                    }
                }
            }
        }
    })
}

func TestDocumentationEndpoints(t *testing.T) {
    router := setupTestRouter(t)
    server := httptest.NewServer(router)
    defer server.Close()

    t.Run("serves OpenAPI JSON", func(t *testing.T) {
        resp, err := http.Get(server.URL + "/api/openapi.json")
        require.NoError(t, err)
        defer resp.Body.Close()

        assert.Equal(t, http.StatusOK, resp.StatusCode)
        assert.Equal(t, "application/json", resp.Header.Get("Content-Type"))

        var spec map[string]interface{}
        err = json.NewDecoder(resp.Body).Decode(&spec)
        assert.NoError(t, err)
        assert.Equal(t, "3.0.3", spec["openapi"])
    })

    t.Run("serves Swagger UI", func(t *testing.T) {
        resp, err := http.Get(server.URL + "/docs/")
        require.NoError(t, err)
        defer resp.Body.Close()

        assert.Equal(t, http.StatusOK, resp.StatusCode)
        assert.Contains(t, resp.Header.Get("Content-Type"), "text/html")
    })
}
```

## Acceptance Criteria

### OpenAPI Specification

- [ ] Complete OpenAPI 3.0.3 specification generated
- [ ] All API endpoints documented with parameters and responses
- [ ] Request/response schemas include examples
- [ ] Authentication and security schemes properly defined
- [ ] Error response schemas documented for all endpoints

### Interactive Documentation

- [ ] Swagger UI accessible at `/docs` endpoint
- [ ] Live API testing functionality available
- [ ] Authentication configuration in UI
- [ ] Request/response examples for all endpoints
- [ ] Mobile-responsive documentation interface

### Documentation Quality

- [ ] All endpoints include comprehensive descriptions
- [ ] Parameter validation rules clearly documented
- [ ] Error codes and messages explained
- [ ] Rate limiting information included
- [ ] Authentication flow examples provided

### Developer Experience

- [ ] Getting started guide with working examples
- [ ] Client library generation support
- [ ] Postman collection export available
- [ ] SDK documentation and examples
- [ ] Integration examples for common use cases

### Automation

- [ ] Documentation generated automatically from code
- [ ] CI/CD pipeline validates OpenAPI specification
- [ ] Documentation deployed automatically on releases
- [ ] Client libraries generated in CI pipeline
- [ ] Documentation versioning and history maintained

## Success Metrics

- OpenAPI specification validates without errors
- 100% of public endpoints documented
- Interactive documentation loads in < 3 seconds
- Developer onboarding time reduced by 50%
- API adoption rate increased through better documentation
