# MVP-021: API Testing & Validation

**Task ID:** MVP-021
**Feature Area:** MVP-TEST
**Priority:** P1 (High)
**Effort Estimate:** 3 days
**Dependencies:** MVP-020 (Integration Testing Suite)

## Objective

Implement comprehensive API testing and validation framework covering performance testing, security validation, contract testing, and API documentation verification to ensure robust and secure API endpoints.

## Business Context

Comprehensive API testing ensures that the application performs well under load, remains secure against common vulnerabilities, and maintains API contract compatibility. This prevents performance degradation, security breaches, and breaking changes that could impact users.

## Technical Requirements

### Core Testing Areas

1. **Performance Testing**

   - Load testing for API endpoints
   - Stress testing under high concurrency
   - Response time and throughput measurement
   - Resource utilization monitoring

2. **Security Testing**

   - Authentication and authorization validation
   - Input validation and injection prevention
   - Rate limiting verification
   - Security header validation

3. **Contract Testing**

   - API schema validation
   - Request/response structure verification
   - OpenAPI specification compliance
   - Breaking change detection

4. **Functional Testing**
   - Endpoint behavior validation
   - Error handling verification
   - Edge case testing
   - Data integrity validation

## Implementation Specification

### Performance Testing Framework

```go
// test/api/performance_test.go
package api

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

type PerformanceTest struct {
    suite       *IntegrationSuite
    httpClient  *http.Client
    baseURL     string
    authTokens  []string
}

func NewPerformanceTest(suite *IntegrationSuite) *PerformanceTest {
    return &PerformanceTest{
        suite:   suite,
        baseURL: suite.apiServer.URL,
        httpClient: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (pt *PerformanceTest) setupTestUsers(count int) {
    pt.authTokens = make([]string, count)

    for i := 0; i < count; i++ {
        email := fmt.Sprintf("perf-user-%d@example.com", i)
        name := fmt.Sprintf("Performance User %d", i)
        pt.authTokens[i] = pt.suite.authenticateTestUser(email, name)
    }
}

func TestAPIPerformance(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    perfTest := NewPerformanceTest(suite)

    t.Run("Load Testing - Journal Creation", func(t *testing.T) {
        const (
            numUsers      = 50
            requestsPerUser = 10
            totalRequests = numUsers * requestsPerUser
        )

        perfTest.setupTestUsers(numUsers)

        // Metrics collection
        var (
            successCount    int64
            errorCount      int64
            totalDuration   time.Duration
            responseTimes   = make([]time.Duration, totalRequests)
            responseIndex   int64
            mu              sync.Mutex
        )

        // WaitGroup for synchronization
        var wg sync.WaitGroup

        startTime := time.Now()

        // Launch concurrent users
        for i := 0; i < numUsers; i++ {
            wg.Add(1)
            go func(userIndex int) {
                defer wg.Done()

                token := perfTest.authTokens[userIndex]

                for j := 0; j < requestsPerUser; j++ {
                    requestStart := time.Now()

                    journalReq := map[string]interface{}{
                        "raw_data": map[string]interface{}{
                            "content": fmt.Sprintf("Load test journal from user %d, request %d", userIndex, j),
                            "mood":    (j%10) + 1,
                        },
                        "entry_type": "text",
                    }

                    resp := perfTest.suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
                    requestDuration := time.Since(requestStart)

                    mu.Lock()
                    if resp.StatusCode == http.StatusCreated {
                        successCount++
                    } else {
                        errorCount++
                    }

                    responseTimes[responseIndex] = requestDuration
                    responseIndex++
                    mu.Unlock()

                    resp.Body.Close()
                }
            }(i)
        }

        wg.Wait()
        totalDuration = time.Since(startTime)

        // Calculate metrics
        mu.Lock()
        defer mu.Unlock()

        successRate := float64(successCount) / float64(totalRequests) * 100
        errorRate := float64(errorCount) / float64(totalRequests) * 100
        throughput := float64(totalRequests) / totalDuration.Seconds()

        // Calculate percentiles
        sortedTimes := make([]time.Duration, len(responseTimes))
        copy(sortedTimes, responseTimes)
        sort.Slice(sortedTimes, func(i, j int) bool {
            return sortedTimes[i] < sortedTimes[j]
        })

        p50 := sortedTimes[int(float64(len(sortedTimes))*0.5)]
        p95 := sortedTimes[int(float64(len(sortedTimes))*0.95)]
        p99 := sortedTimes[int(float64(len(sortedTimes))*0.99)]

        // Performance assertions
        assert.GreaterOrEqual(t, successRate, 95.0, "Success rate should be >= 95%")
        assert.LessOrEqual(t, errorRate, 5.0, "Error rate should be <= 5%")
        assert.GreaterOrEqual(t, throughput, 10.0, "Throughput should be >= 10 requests/second")
        assert.LessOrEqual(t, p95, 2*time.Second, "95th percentile should be <= 2 seconds")
        assert.LessOrEqual(t, p99, 5*time.Second, "99th percentile should be <= 5 seconds")

        // Log performance metrics
        t.Logf("Performance Metrics:")
        t.Logf("  Total Requests: %d", totalRequests)
        t.Logf("  Success Rate: %.2f%%", successRate)
        t.Logf("  Error Rate: %.2f%%", errorRate)
        t.Logf("  Throughput: %.2f req/sec", throughput)
        t.Logf("  Response Times:")
        t.Logf("    P50: %v", p50)
        t.Logf("    P95: %v", p95)
        t.Logf("    P99: %v", p99)
        t.Logf("  Total Duration: %v", totalDuration)
    })

    t.Run("Stress Testing - High Concurrency", func(t *testing.T) {
        const (
            numConcurrentUsers = 100
            testDuration      = 30 * time.Second
        )

        perfTest.setupTestUsers(numConcurrentUsers)

        var (
            requestCount  int64
            errorCount    int64
            mu           sync.Mutex
            ctx, cancel  = context.WithTimeout(context.Background(), testDuration)
        )
        defer cancel()

        var wg sync.WaitGroup

        // Launch stress test workers
        for i := 0; i < numConcurrentUsers; i++ {
            wg.Add(1)
            go func(userIndex int) {
                defer wg.Done()

                token := perfTest.authTokens[userIndex]

                for {
                    select {
                    case <-ctx.Done():
                        return
                    default:
                        // Make request
                        resp := perfTest.suite.makeAuthenticatedRequest("GET", "/api/journals?limit=10", nil, token)

                        mu.Lock()
                        requestCount++
                        if resp.StatusCode != http.StatusOK {
                            errorCount++
                        }
                        mu.Unlock()

                        resp.Body.Close()

                        // Small delay to prevent overwhelming
                        time.Sleep(10 * time.Millisecond)
                    }
                }
            }(i)
        }

        wg.Wait()

        mu.Lock()
        totalRequests := requestCount
        totalErrors := errorCount
        mu.Unlock()

        errorRate := float64(totalErrors) / float64(totalRequests) * 100
        avgThroughput := float64(totalRequests) / testDuration.Seconds()

        // Stress test assertions
        assert.LessOrEqual(t, errorRate, 10.0, "Error rate under stress should be <= 10%")
        assert.GreaterOrEqual(t, avgThroughput, 50.0, "Throughput under stress should be >= 50 req/sec")

        t.Logf("Stress Test Metrics:")
        t.Logf("  Duration: %v", testDuration)
        t.Logf("  Concurrent Users: %d", numConcurrentUsers)
        t.Logf("  Total Requests: %d", totalRequests)
        t.Logf("  Error Rate: %.2f%%", errorRate)
        t.Logf("  Average Throughput: %.2f req/sec", avgThroughput)
    })

    t.Run("Memory Usage Under Load", func(t *testing.T) {
        var memStatsBefore, memStatsAfter runtime.MemStats

        runtime.GC()
        runtime.ReadMemStats(&memStatsBefore)

        // Perform load test
        const numRequests = 100
        perfTest.setupTestUsers(10)

        var wg sync.WaitGroup
        for i := 0; i < numRequests; i++ {
            wg.Add(1)
            go func(index int) {
                defer wg.Done()

                token := perfTest.authTokens[index%len(perfTest.authTokens)]
                journalReq := map[string]interface{}{
                    "raw_data": map[string]interface{}{
                        "content": fmt.Sprintf("Memory test journal %d with longer content to test memory usage patterns", index),
                    },
                }

                resp := perfTest.suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
                resp.Body.Close()
            }(i)
        }
        wg.Wait()

        runtime.GC()
        runtime.ReadMemStats(&memStatsAfter)

        memoryIncrease := memStatsAfter.Alloc - memStatsBefore.Alloc
        memoryIncreasePerRequest := float64(memoryIncrease) / float64(numRequests)

        t.Logf("Memory Usage:")
        t.Logf("  Before: %d bytes", memStatsBefore.Alloc)
        t.Logf("  After: %d bytes", memStatsAfter.Alloc)
        t.Logf("  Increase: %d bytes", memoryIncrease)
        t.Logf("  Per Request: %.2f bytes", memoryIncreasePerRequest)

        // Memory assertions (should not increase dramatically)
        assert.LessOrEqual(t, memoryIncreasePerRequest, 50000.0, "Memory per request should be reasonable")
    })
}
```

### Security Testing Framework

```go
// test/api/security_test.go
package api

import (
    "fmt"
    "net/http"
    "net/url"
    "strings"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestAPISecurity(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    t.Run("Authentication Security", func(t *testing.T) {
        // Test accessing protected endpoints without authentication
        protectedEndpoints := []string{
            "/api/user/profile",
            "/api/journals",
            "/api/journals/123",
        }

        for _, endpoint := range protectedEndpoints {
            t.Run(fmt.Sprintf("Unauthorized access to %s", endpoint), func(t *testing.T) {
                resp := suite.makeRequest("GET", endpoint, nil)
                assert.Equal(t, http.StatusUnauthorized, resp.StatusCode)
                resp.Body.Close()
            })
        }

        // Test with invalid token
        t.Run("Invalid token", func(t *testing.T) {
            req, _ := http.NewRequest("GET", suite.apiServer.URL+"/api/user/profile", nil)
            req.Header.Set("Authorization", "Bearer invalid-token-here")

            resp, err := http.DefaultClient.Do(req)
            require.NoError(t, err)
            defer resp.Body.Close()

            assert.Equal(t, http.StatusUnauthorized, resp.StatusCode)
        })

        // Test with malformed token
        t.Run("Malformed token", func(t *testing.T) {
            req, _ := http.NewRequest("GET", suite.apiServer.URL+"/api/user/profile", nil)
            req.Header.Set("Authorization", "InvalidScheme token-here")

            resp, err := http.DefaultClient.Do(req)
            require.NoError(t, err)
            defer resp.Body.Close()

            assert.Equal(t, http.StatusUnauthorized, resp.StatusCode)
        })
    })

    t.Run("Input Validation Security", func(t *testing.T) {
        token := suite.authenticateTestUser("security-test@example.com", "Security Test User")

        // SQL Injection attempts
        sqlInjectionPayloads := []string{
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "admin'--",
            "' UNION SELECT * FROM users --",
            "1'; DELETE FROM journal_entries; --",
        }

        for _, payload := range sqlInjectionPayloads {
            t.Run(fmt.Sprintf("SQL Injection: %s", payload), func(t *testing.T) {
                journalReq := map[string]interface{}{
                    "raw_data": map[string]interface{}{
                        "content": payload,
                        "title":   payload,
                    },
                }

                resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
                // Should not return 500 (internal server error)
                assert.NotEqual(t, http.StatusInternalServerError, resp.StatusCode)
                resp.Body.Close()
            })
        }

        // XSS attempts
        xssPayloads := []string{
            "<script>alert('xss')</script>",
            "javascript:alert('xss')",
            "<img src=x onerror=alert('xss')>",
            "&#60;script&#62;alert('xss')&#60;/script&#62;",
            "<svg onload=alert('xss')>",
        }

        for _, payload := range xssPayloads {
            t.Run(fmt.Sprintf("XSS: %s", payload), func(t *testing.T) {
                journalReq := map[string]interface{}{
                    "raw_data": map[string]interface{}{
                        "content": payload,
                    },
                }

                resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
                assert.True(t, resp.StatusCode == http.StatusCreated || resp.StatusCode == http.StatusBadRequest)
                resp.Body.Close()
            })
        }

        // Large payload attack
        t.Run("Large Payload Attack", func(t *testing.T) {
            largeContent := strings.Repeat("A", 1024*1024) // 1MB content

            journalReq := map[string]interface{}{
                "raw_data": map[string]interface{}{
                    "content": largeContent,
                },
            }

            resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
            // Should handle large payloads gracefully
            assert.True(t, resp.StatusCode == http.StatusBadRequest || resp.StatusCode == http.StatusRequestEntityTooLarge)
            resp.Body.Close()
        })
    })

    t.Run("Rate Limiting Security", func(t *testing.T) {
        // Test rate limiting on authentication endpoints
        t.Run("Authentication Rate Limiting", func(t *testing.T) {
            var statusCodes []int

            // Make rapid requests to trigger rate limiting
            for i := 0; i < 20; i++ {
                otpReq := map[string]string{
                    "email": fmt.Sprintf("rate-test-%d@example.com", i),
                }

                resp := suite.makeRequest("POST", "/api/auth/otp/request", otpReq)
                statusCodes = append(statusCodes, resp.StatusCode)
                resp.Body.Close()
            }

            // Check if rate limiting kicked in
            rateLimitTriggered := false
            for _, code := range statusCodes {
                if code == http.StatusTooManyRequests {
                    rateLimitTriggered = true
                    break
                }
            }

            assert.True(t, rateLimitTriggered, "Rate limiting should be triggered for auth endpoints")
        })

        // Test rate limiting on API endpoints
        t.Run("API Rate Limiting", func(t *testing.T) {
            token := suite.authenticateTestUser("rate-limit-test@example.com", "Rate Limit Test")
            var statusCodes []int

            // Make rapid requests
            for i := 0; i < 150; i++ {
                resp := suite.makeAuthenticatedRequest("GET", "/api/journals", nil, token)
                statusCodes = append(statusCodes, resp.StatusCode)
                resp.Body.Close()
            }

            // Check if rate limiting kicked in
            rateLimitTriggered := false
            for _, code := range statusCodes {
                if code == http.StatusTooManyRequests {
                    rateLimitTriggered = true
                    break
                }
            }

            assert.True(t, rateLimitTriggered, "Rate limiting should be triggered for API endpoints")
        })
    })

    t.Run("Security Headers", func(t *testing.T) {
        resp := suite.makeRequest("GET", "/api/health", nil)
        defer resp.Body.Close()

        // Check security headers
        assert.Equal(t, "nosniff", resp.Header.Get("X-Content-Type-Options"))
        assert.Equal(t, "DENY", resp.Header.Get("X-Frame-Options"))
        assert.Contains(t, resp.Header.Get("Content-Security-Policy"), "default-src 'self'")
        assert.Contains(t, resp.Header.Get("Strict-Transport-Security"), "max-age=")
        assert.NotEmpty(t, resp.Header.Get("Referrer-Policy"))
    })

    t.Run("Authorization Security", func(t *testing.T) {
        // Create two users
        token1 := suite.authenticateTestUser("user1@example.com", "User 1")
        token2 := suite.authenticateTestUser("user2@example.com", "User 2")

        // User 1 creates a journal
        journalReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "content": "This is user 1's private journal",
            },
        }

        resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token1)
        require.Equal(t, http.StatusCreated, resp.StatusCode)

        var createResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&createResp)
        require.NoError(t, err)
        journalID := createResp["id"].(string)

        // User 2 tries to access User 1's journal
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID, nil, token2)
        assert.True(t, resp.StatusCode == http.StatusNotFound || resp.StatusCode == http.StatusForbidden)
        resp.Body.Close()

        // User 2 tries to modify User 1's journal
        updateReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "content": "Trying to modify another user's journal",
            },
        }

        resp = suite.makeAuthenticatedRequest("PUT", "/api/journals/"+journalID, updateReq, token2)
        assert.True(t, resp.StatusCode == http.StatusNotFound || resp.StatusCode == http.StatusForbidden)
        resp.Body.Close()

        // User 2 tries to delete User 1's journal
        resp = suite.makeAuthenticatedRequest("DELETE", "/api/journals/"+journalID, nil, token2)
        assert.True(t, resp.StatusCode == http.StatusNotFound || resp.StatusCode == http.StatusForbidden)
        resp.Body.Close()
    })
}
```

### Contract Testing Framework

```go
// test/api/contract_test.go
package api

import (
    "encoding/json"
    "io"
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/xeipuuv/gojsonschema"
)

// JSON Schema definitions for API responses
var (
    userSchema = `{
        "type": "object",
        "required": ["id", "email", "name", "created_at"],
        "properties": {
            "id": {"type": "string", "format": "uuid"},
            "email": {"type": "string", "format": "email"},
            "name": {"type": "string"},
            "auth_provider": {"type": ["string", "null"]},
            "created_at": {"type": "string", "format": "date-time"},
            "updated_at": {"type": "string", "format": "date-time"}
        },
        "additionalProperties": false
    }`

    journalSchema = `{
        "type": "object",
        "required": ["id", "user_id", "raw_data", "entry_type", "processing_status", "created_at"],
        "properties": {
            "id": {"type": "string", "format": "uuid"},
            "user_id": {"type": "string", "format": "uuid"},
            "raw_data": {"type": "object"},
            "entry_type": {"type": "string", "enum": ["text", "voice", "photo", "mixed"]},
            "metadata": {"type": "object"},
            "processing_status": {"type": "string", "enum": ["pending", "processing", "completed", "failed"]},
            "created_at": {"type": "string", "format": "date-time"},
            "updated_at": {"type": "string", "format": "date-time"}
        },
        "additionalProperties": false
    }`

    processedContentSchema = `{
        "type": "object",
        "required": ["id", "journal_id", "user_id", "task_type", "processed_data", "created_at"],
        "properties": {
            "id": {"type": "string", "format": "uuid"},
            "journal_id": {"type": "string", "format": "uuid"},
            "user_id": {"type": "string", "format": "uuid"},
            "task_type": {"type": "string"},
            "processed_data": {"type": "object"},
            "confidence_score": {"type": ["number", "null"], "minimum": 0, "maximum": 1},
            "ai_provider_info": {"type": ["object", "null"]},
            "created_at": {"type": "string", "format": "date-time"}
        },
        "additionalProperties": false
    }`

    errorSchema = `{
        "type": "object",
        "required": ["error"],
        "properties": {
            "error": {
                "type": "object",
                "required": ["code", "message", "timestamp"],
                "properties": {
                    "code": {"type": "string"},
                    "message": {"type": "string"},
                    "timestamp": {"type": "string", "format": "date-time"},
                    "details": {"type": "object"},
                    "request_id": {"type": "string"}
                }
            }
        },
        "additionalProperties": false
    }`
)

func validateJSONSchema(t *testing.T, schemaStr string, data interface{}) {
    schema := gojsonschema.NewStringLoader(schemaStr)
    document := gojsonschema.NewGoLoader(data)

    result, err := gojsonschema.Validate(schema, document)
    require.NoError(t, err)

    if !result.Valid() {
        for _, desc := range result.Errors() {
            t.Errorf("Schema validation error: %s", desc)
        }
        t.FailNow()
    }
}

func TestAPIContract(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    token := suite.authenticateTestUser("contract-test@example.com", "Contract Test User")

    t.Run("User Profile Response Contract", func(t *testing.T) {
        resp := suite.makeAuthenticatedRequest("GET", "/api/user/profile", nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var user map[string]interface{}
        err = json.Unmarshal(body, &user)
        require.NoError(t, err)

        validateJSONSchema(t, userSchema, user)

        // Additional contract validations
        assert.Equal(t, "contract-test@example.com", user["email"])
        assert.Equal(t, "Contract Test User", user["name"])
    })

    t.Run("Journal Creation Response Contract", func(t *testing.T) {
        journalReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "content": "Contract test journal entry",
                "mood":    7,
            },
            "entry_type": "text",
        }

        resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var journal map[string]interface{}
        err = json.Unmarshal(body, &journal)
        require.NoError(t, err)

        validateJSONSchema(t, journalSchema, journal)

        // Additional contract validations
        assert.Equal(t, "text", journal["entry_type"])
        assert.Equal(t, "pending", journal["processing_status"])
        assert.NotEmpty(t, journal["id"])
        assert.NotEmpty(t, journal["user_id"])
    })

    t.Run("Journal List Response Contract", func(t *testing.T) {
        resp := suite.makeAuthenticatedRequest("GET", "/api/journals?limit=10&offset=0", nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var listResponse map[string]interface{}
        err = json.Unmarshal(body, &listResponse)
        require.NoError(t, err)

        // Validate list response structure
        assert.Contains(t, listResponse, "journals")
        assert.Contains(t, listResponse, "total")
        assert.Contains(t, listResponse, "limit")
        assert.Contains(t, listResponse, "offset")

        journals := listResponse["journals"].([]interface{})
        for _, journal := range journals {
            validateJSONSchema(t, journalSchema, journal)
        }
    })

    t.Run("Processed Content Response Contract", func(t *testing.T) {
        // First create a journal and wait for processing
        journalReq := map[string]interface{}{
            "raw_data": map[string]interface{}{
                "content": "This is a test for processed content contract validation",
            },
            "entry_type": "text",
        }

        resp := suite.makeAuthenticatedRequest("POST", "/api/journals", journalReq, token)
        require.Equal(t, http.StatusCreated, resp.StatusCode)

        var createResp map[string]interface{}
        err := json.NewDecoder(resp.Body).Decode(&createResp)
        require.NoError(t, err)

        journalID := createResp["id"].(string)

        // Wait for processing
        suite.waitForProcessingComplete(journalID, token, 30*time.Second)

        // Get processed content
        resp = suite.makeAuthenticatedRequest("GET", "/api/journals/"+journalID+"/processed", nil, token)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var processedResponse map[string]interface{}
        err = json.Unmarshal(body, &processedResponse)
        require.NoError(t, err)

        assert.Contains(t, processedResponse, "processed_content")
        processedContent := processedResponse["processed_content"].([]interface{})

        for _, content := range processedContent {
            validateJSONSchema(t, processedContentSchema, content)
        }
    })

    t.Run("Error Response Contract", func(t *testing.T) {
        // Test with invalid journal ID
        resp := suite.makeAuthenticatedRequest("GET", "/api/journals/invalid-uuid", nil, token)
        assert.Equal(t, http.StatusBadRequest, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var errorResponse map[string]interface{}
        err = json.Unmarshal(body, &errorResponse)
        require.NoError(t, err)

        validateJSONSchema(t, errorSchema, errorResponse)

        errorObj := errorResponse["error"].(map[string]interface{})
        assert.NotEmpty(t, errorObj["code"])
        assert.NotEmpty(t, errorObj["message"])
        assert.NotEmpty(t, errorObj["timestamp"])
    })

    t.Run("Content-Type Headers", func(t *testing.T) {
        resp := suite.makeAuthenticatedRequest("GET", "/api/user/profile", nil, token)
        assert.Equal(t, "application/json; charset=utf-8", resp.Header.Get("Content-Type"))
        resp.Body.Close()
    })

    t.Run("API Versioning", func(t *testing.T) {
        // Test that API version is properly handled in URLs
        resp := suite.makeAuthenticatedRequest("GET", "/api/v1/user/profile", nil, token)
        // Should either work (if v1 is supported) or return proper error
        assert.True(t, resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusNotFound)
        resp.Body.Close()
    })
}
```

### API Documentation Testing

```go
// test/api/documentation_test.go
package api

import (
    "encoding/json"
    "io"
    "net/http"
    "strings"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestAPIDocumentation(t *testing.T) {
    suite := NewIntegrationSuite(t)
    defer suite.Cleanup()

    t.Run("OpenAPI Specification Accessibility", func(t *testing.T) {
        resp := suite.makeRequest("GET", "/api/docs/openapi.json", nil)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var openapi map[string]interface{}
        err = json.Unmarshal(body, &openapi)
        require.NoError(t, err)

        // Validate OpenAPI structure
        assert.Equal(t, "3.0.0", openapi["openapi"])
        assert.Contains(t, openapi, "info")
        assert.Contains(t, openapi, "paths")
        assert.Contains(t, openapi, "components")

        info := openapi["info"].(map[string]interface{})
        assert.Equal(t, "EngLog API", info["title"])
        assert.Contains(t, info, "version")
    })

    t.Run("Swagger UI Accessibility", func(t *testing.T) {
        resp := suite.makeRequest("GET", "/api/docs/", nil)
        assert.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        htmlContent := string(body)
        assert.Contains(t, htmlContent, "swagger-ui")
        assert.Contains(t, htmlContent, "EngLog API")
    })

    t.Run("API Endpoint Documentation Coverage", func(t *testing.T) {
        resp := suite.makeRequest("GET", "/api/docs/openapi.json", nil)
        require.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var openapi map[string]interface{}
        err = json.Unmarshal(body, &openapi)
        require.NoError(t, err)

        paths := openapi["paths"].(map[string]interface{})

        // Check that all major endpoints are documented
        expectedEndpoints := []string{
            "/auth/register",
            "/auth/otp/request",
            "/auth/otp/verify",
            "/auth/refresh",
            "/user/profile",
            "/journals",
            "/journals/{id}",
            "/journals/{id}/processed",
        }

        for _, endpoint := range expectedEndpoints {
            found := false
            for path := range paths {
                if strings.Contains(path, endpoint) || path == endpoint {
                    found = true
                    break
                }
            }
            assert.True(t, found, "Endpoint %s should be documented", endpoint)
        }
    })

    t.Run("Schema Definitions Coverage", func(t *testing.T) {
        resp := suite.makeRequest("GET", "/api/docs/openapi.json", nil)
        require.Equal(t, http.StatusOK, resp.StatusCode)

        body, err := io.ReadAll(resp.Body)
        require.NoError(t, err)

        var openapi map[string]interface{}
        err = json.Unmarshal(body, &openapi)
        require.NoError(t, err)

        components := openapi["components"].(map[string]interface{})
        schemas := components["schemas"].(map[string]interface{})

        // Check that all major schemas are defined
        expectedSchemas := []string{
            "User",
            "JournalEntry",
            "ProcessedContent",
            "ErrorResponse",
            "CreateJournalRequest",
            "AuthRequest",
        }

        for _, schema := range expectedSchemas {
            assert.Contains(t, schemas, schema, "Schema %s should be defined", schema)
        }
    })
}
```

### Load Testing with Artillery Integration

```yaml
# test/api/load-test.yml
config:
  target: "{{ $processEnvironment.API_BASE_URL || 'http://localhost:8080' }}"
  phases:
    - duration: 30
      arrivalRate: 5
      name: "Warm up"
    - duration: 60
      arrivalRate: 20
      name: "Ramp up load"
    - duration: 180
      arrivalRate: 50
      name: "Sustained load"
    - duration: 60
      arrivalRate: 100
      name: "Peak load"

  variables:
    testEmail: "loadtest-{{ $uuid }}@example.com"
    testName: "Load Test User {{ $uuid }}"

scenarios:
  - name: "Authentication and Journal Operations"
    weight: 80
    flow:
      # Register and authenticate
      - post:
          url: "/api/auth/register"
          json:
            email: "{{ testEmail }}"
            name: "{{ testName }}"
          capture:
            - json: "$.user_id"
              as: "userId"

      - post:
          url: "/api/auth/otp/verify"
          json:
            email: "{{ testEmail }}"
            code: "123456"
          capture:
            - json: "$.access_token"
              as: "accessToken"

      - think: 2

      # Create journal entries
      - loop:
          - post:
              url: "/api/journals"
              headers:
                Authorization: "Bearer {{ accessToken }}"
              json:
                raw_data:
                  content: "Load test journal entry with meaningful content for AI processing. Today I learned about testing and performance optimization."
                  mood: "{{ $randomInt(1, 10) }}"
                  tags: ["loadtest", "performance"]
              capture:
                - json: "$.id"
                  as: "journalId"
          - think: 1
          - get:
              url: "/api/journals/{{ journalId }}"
              headers:
                Authorization: "Bearer {{ accessToken }}"
        count: 3

      # List journals
      - get:
          url: "/api/journals?limit=10&offset=0"
          headers:
            Authorization: "Bearer {{ accessToken }}"

  - name: "Read-only Operations"
    weight: 20
    flow:
      # Use existing authenticated user
      - post:
          url: "/api/auth/otp/verify"
          json:
            email: "existing-user@example.com"
            code: "123456"
          capture:
            - json: "$.access_token"
              as: "accessToken"

      # Perform read operations
      - get:
          url: "/api/user/profile"
          headers:
            Authorization: "Bearer {{ accessToken }}"

      - get:
          url: "/api/journals"
          headers:
            Authorization: "Bearer {{ accessToken }}"

      - think: 1

      - get:
          url: "/api/journals?limit=20&offset=0"
          headers:
            Authorization: "Bearer {{ accessToken }}"
```

### Test Configuration and Scripts

```bash
#!/bin/bash
# test/api/run-performance-tests.sh

set -e

echo "Starting API Performance Tests..."

# Set up test environment
export API_BASE_URL="http://localhost:8080"
export TEST_MODE="performance"

# Start test containers if needed
if [ "$1" = "--with-containers" ]; then
    echo "Starting test containers..."
    docker-compose -f docker-compose.test.yml up -d

    # Wait for services to be ready
    echo "Waiting for services to be ready..."
    sleep 30
fi

# Run Go performance tests
echo "Running Go performance tests..."
go test -v -timeout=600s -run=TestAPIPerformance ./test/api/

# Run Artillery load tests if available
if command -v artillery &> /dev/null; then
    echo "Running Artillery load tests..."
    artillery run test/api/load-test.yml --output performance-report.json
    artillery report performance-report.json --output performance-report.html
    echo "Performance report generated: performance-report.html"
fi

# Run security tests
echo "Running security tests..."
go test -v -timeout=300s -run=TestAPISecurity ./test/api/

# Run contract tests
echo "Running contract tests..."
go test -v -timeout=300s -run=TestAPIContract ./test/api/

echo "All API tests completed!"

# Cleanup if we started containers
if [ "$1" = "--with-containers" ]; then
    echo "Stopping test containers..."
    docker-compose -f docker-compose.test.yml down
fi
```

### Makefile Integration

```makefile
# Add to project Makefile

.PHONY: test-api-performance
test-api-performance:
	@echo "Running API performance tests..."
	@go test -v -timeout=600s -run=TestAPIPerformance ./test/api/

.PHONY: test-api-security
test-api-security:
	@echo "Running API security tests..."
	@go test -v -timeout=300s -run=TestAPISecurity ./test/api/

.PHONY: test-api-contract
test-api-contract:
	@echo "Running API contract tests..."
	@go test -v -timeout=300s -run=TestAPIContract ./test/api/

.PHONY: test-api-all
test-api-all: test-api-performance test-api-security test-api-contract
	@echo "All API tests completed"

.PHONY: load-test
load-test:
	@echo "Running load tests with Artillery..."
	@artillery run test/api/load-test.yml --output load-test-report.json
	@artillery report load-test-report.json --output load-test-report.html
	@echo "Load test report: load-test-report.html"

.PHONY: test-api-with-report
test-api-with-report:
	@./test/api/run-performance-tests.sh --with-containers
```

## Acceptance Criteria

### Performance Requirements

- [ ] **Load Testing**

  - Handle 50+ concurrent users creating journals
  - Maintain 95%+ success rate under load
  - API response time P95 ≤ 2 seconds
  - Throughput ≥ 10 requests/second

- [ ] **Stress Testing**
  - Handle 100+ concurrent users for 30 seconds
  - Error rate ≤ 10% under stress
  - System recovery after stress test
  - Memory usage remains stable

### Security Requirements

- [ ] **Authentication Security**

  - All protected endpoints require valid authentication
  - Invalid/expired tokens properly rejected
  - Authorization prevents cross-user data access
  - Rate limiting prevents brute force attacks

- [ ] **Input Validation**
  - SQL injection attempts blocked
  - XSS payloads properly sanitized
  - Large payloads handled gracefully
  - Security headers properly set

### Contract Requirements

- [ ] **Response Schemas**

  - All API responses match defined schemas
  - Error responses follow standard format
  - Required fields always present
  - Data types correctly specified

- [ ] **API Documentation**
  - OpenAPI specification accessible
  - All endpoints documented
  - Schema definitions complete
  - Swagger UI functional

### Quality Requirements

- [ ] **Test Coverage**

  - 100% of API endpoints tested
  - All security vulnerabilities checked
  - Performance baselines established
  - Contract compliance verified

- [ ] **Automation**
  - Tests run in CI/CD pipeline
  - Performance reports generated
  - Security scan automation
  - Contract testing integrated

## Dependencies

### Technical Dependencies

- **MVP-020:** Integration Testing Suite (test infrastructure)
- **MVP-008:** Authenticated Journal CRUD API (API endpoints)
- **MVP-017:** Rate Limiting & Security Middleware (security features)
- **MVP-018:** API Documentation & OpenAPI Spec (documentation)

### Testing Tools

- **Artillery:** Load testing framework
- **gojsonschema:** JSON schema validation
- **testify:** Testing assertions and utilities
- **Go net/http:** HTTP client testing
- **Docker Testcontainers:** Isolated test environments

## Risks and Mitigation

### Technical Risks

1. **Performance Test Reliability**

   - Risk: Inconsistent performance results
   - Mitigation: Multiple test runs, baseline establishment, environment isolation

2. **Security Test Completeness**

   - Risk: Missing security vulnerabilities
   - Mitigation: Regular security test updates, external security audit

3. **Contract Testing Maintenance**
   - Risk: Schema drift and outdated tests
   - Mitigation: Automated schema generation, CI/CD integration

### Operational Risks

1. **Test Environment Complexity**

   - Risk: Difficult setup and maintenance
   - Mitigation: Containerized test environment, clear documentation

2. **CI/CD Performance Impact**
   - Risk: Tests too slow for CI pipeline
   - Mitigation: Test categorization, parallel execution, smart test selection

## Success Metrics

- **Performance:** All performance targets met consistently
- **Security:** Zero security vulnerabilities detected
- **Contract:** 100% API contract compliance
- **Coverage:** Complete test coverage of all API endpoints
- **Automation:** All tests integrated in CI/CD pipeline

## Future Enhancements

- **Chaos Engineering:** Fault injection testing
- **A/B Testing:** API version compatibility testing
- **Monitoring Integration:** Performance monitoring in production
- **Security Scanning:** Automated vulnerability scanning integration
